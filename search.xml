<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HDU 6373 Pinball</title>
    <url>/2018/09/28/HDU-6373-Pinball/</url>
    <content><![CDATA[<p>嘛，做科协的新生赛题目碰到了，这里记录一下思路。题目如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pinball</span><br><span class="line"></span><br><span class="line">Time Limit: 2000&#x2F;1000 MS (Java&#x2F;Others)    Memory Limit: 262144&#x2F;262144 K (Java&#x2F;Others)</span><br><span class="line">Total Submission(s): 574    Accepted Submission(s): 249</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Problem Description</span><br><span class="line"></span><br><span class="line">There is a slope on the 2D plane. The lowest point of the slope is at the origin. There is a small ball falling down above the slope. Your task is to find how many times the ball has been bounced on the slope.</span><br><span class="line"></span><br><span class="line">It&#39;s guarantee that the ball will not reach the slope or ground or Y-axis with a distance of less than 1 from the origin. And the ball is elastic collision without energy loss. Gravity acceleration g&#x3D;9.8m&#x2F;s2.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line"></span><br><span class="line">There are multiple test cases. The first line of input contains an integer T (1 ≤ T ≤ 100), indicating the number of test cases.</span><br><span class="line"></span><br><span class="line">The first line of each test case contains four integers a, b, x, y (1 ≤ a, b, -x, y ≤ 100), indicate that the slope will pass through the point(-a, b), the initial position of the ball is (x, y).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">Output the answer.</span><br><span class="line"></span><br><span class="line">It&#39;s guarantee that the answer will not exceed 50.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Sample Input</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">5 1 -5 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sample Output</span><br><span class="line"></span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p> 这题基本上是物理题，我看了大多数人的写法，大都是计算每次跳跃的距离然后判断。这题数据算是比较小的，这样当然要过也很容易，这里给出一个另一个思路。按照沿斜面方向和垂直斜面方向分解之后，沿斜面方向是典型的匀加速直线运动，直接求出距离然后计算总时间（二次方程求根），而每次跳跃的时间都是固定的，所以总时间再除以每次跳跃的时间，结果就出来了。这样非常快，时间空间复杂度都是常数，在vj平台上显示用时为0。</p>
<p>AC代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define ld long double</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const ll tests[][4] &#x3D; &#123;</span><br><span class="line">	&#123;5,1,-5,3&#125;,</span><br><span class="line">	&#123;99,17,-97,25&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	std::ios::sync_with_stdio(false);</span><br><span class="line">	cin.tie(NULL), cout.tie(NULL);</span><br><span class="line"></span><br><span class="line">	ll a, b, x, y;</span><br><span class="line">	const ld pi &#x3D; acos(-1);</span><br><span class="line">	const ld pi2 &#x3D; pi &#x2F; 2;</span><br><span class="line">	const ld g &#x3D; 9.8;</span><br><span class="line"></span><br><span class="line">	ld v0, ax, ay, vx, vy, tan0, sin0, cos0, h0, l0, tt, t0;</span><br><span class="line"></span><br><span class="line">	ll T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		</span><br><span class="line">		tan0 &#x3D; (ld)b &#x2F; a;</span><br><span class="line">		h0 &#x3D; y - (-x)*tan0;</span><br><span class="line">		v0 &#x3D; sqrt(2 * g*h0);</span><br><span class="line">		sin0 &#x3D; sqrt(1 - 1 &#x2F; (tan0*tan0 + 1));</span><br><span class="line">		cos0 &#x3D; sqrt(1 &#x2F; (tan0*tan0 + 1));</span><br><span class="line">		l0 &#x3D; (-x) &#x2F; cos0;&#x2F;&#x2F;总长度</span><br><span class="line">		vx &#x3D; v0 * sin0;</span><br><span class="line">		vy &#x3D; v0 * cos0;</span><br><span class="line">		ax &#x3D; g * sin0;</span><br><span class="line">		ay &#x3D; g * cos0;</span><br><span class="line">		t0 &#x3D; 2 * vy &#x2F; ay;&#x2F;&#x2F;单次跳跃时间</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;解方程，1&#x2F;2*ax*t*t+vx*t&#x3D;l0</span><br><span class="line">		tt &#x3D; (sqrt(vx*vx + 2 * ax*l0) - vx) &#x2F; ax;</span><br><span class="line">		cout &lt;&lt; (ll)(tt &#x2F; t0) + 1 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>数学与几何</category>
        <category>物理题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>ICPC</tag>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title>NRF24L01 调试笔记</title>
    <url>/2020/07/30/NRF24L01-%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>前几天想要做一个开源航模接收机，于是去淘宝看了下无线模块，以前有了解过NRF24L01，于是就下单了三片，一片才8块钱，真的划算。</p>
<span id="more"></span>

<h2 id="初体验"><a href="#初体验" class="headerlink" title="初体验"></a>初体验</h2><p>到手后才知道这玩意是SPI协议，以前也只是听说过，没有实际写过有关SPI的东西，都是串口用得多，我寻思着太莽了不合适，正好卖家有一个这玩意的<a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.3c882e8dsDyyP2&id=525017079092&_u=u2fd7nfqacf1">调试器</a>（说是调试器，其实就是用AT命令来控制），于是又下单了两个。</p>
<p>到手后插上，灯闪烁，说明检测到模块了，于是打开串口工具，乱码。与卖家PY一番后得知这玩意传输的是中文字符串，还是GBK编码，真是裂开，以前知道硬件工程师一般比较落后，没想到这么落后。</p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>通过那个调试器我了解了这模块的一些基本操作。首先模块需要配置发送地址和接收地址（5字节），大概类似于配对，比如A模块的发送地址是<code>0x11 0x22 0x33 0x44 0x55</code>，接收地址是<code>0x11 0x22 0x33 0x44 0x56</code>，那么如果有一个B模块想要与A模块通信，就需要把B模块的发送地址配置为<code>0x11 0x22 0x33 0x44 0x56</code>，接收地址配置为<code>0x11 0x22 0x33 0x44 0x55</code>，还要设置同样的CRC校验以及同样的频段就可以相互通信了。</p>
<p>之前看的教程提到地址都不明确说，搞得我一头雾水。</p>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>有关SPI的介绍网上很多，这里不再赘述。但是要提一点，这玩意虽然硬件上是全双工，但是它和UART不一样，它并不是对等协议，也就是说从机不能主动发起通信，主机在拉低从机的片选信号后会控制SCLK信号，这时候从机才能发送给主机，也就是说这玩意在软件层面上还是属于半双工。</p>
<p>我使用的单片机是STM32，之前被坑了好久，与串口类似，SPI也有一系列<code>HAL_SPI</code>函数，比如<code>HAL_SPI_Transmit</code>和<code>HAL_SPI_Receive</code>，以及对应的<code>_IT</code>和<code>_DMA</code>，但是我们前面提到了SPI与串口的不同之处，也就是说，SPI的发送和接收是同时进行的，而且发送的长度和接收的长度相等，我在写串口的时候习惯于一直调用<code>HAL_UART_Receive_IT</code>来保证串口数据不会被丢失，因为串口可以抽象成一般的字节流，如果没有数据当然不会触发中断，但是SPI它不一样就在这里了，一旦调用<code>HAL_SPI_Receive_IT</code>就一定会触发中断，这时候得到的数据由MISO引脚的电平决定，也就是说<strong>无论有没有接设备，都一定能收到“数据”</strong>，这导致我之前调试的时候根本没接设备还能不停收到0或者255这一情况是懵逼的，后来才专门补了SPI的相关知识。</p>
<h2 id="NRF24L01"><a href="#NRF24L01" class="headerlink" title="NRF24L01"></a>NRF24L01</h2><p><a href="https://www.sparkfun.com/datasheets/Components/SMD/nRF24L01Pluss_Preliminary_Product_Specification_v1_0.pdf">Datasheet</a>是很重要的资料，如果你还没有，可以从链接里下载。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>总的来说，NRF24L01使用SPI发送命令来控制，具体可以看Datasheet的8.3.1节。</p>
<p>每一组命令由片选信号下降沿开始，上升沿结束。具我自己的测试，STM32的硬件SPI片选好像不太行，得手动操作GPIO，每次发送命令前拉低片选引脚，发送和接收完毕后再拉高。</p>
<p>总共有11个命令，长度都是固定的1字节。操作寄存器可以用R_REGISTER和W_REGISTER，携带1～5字节的数据，前面提到过，SPI的发送和接收同时进行同时结束，拿读取寄存器来说，如果要读取5个字节的话，就得发送6个字节（有一个字节是命令本身），除了命令那个字节以为后面跟的是啥并不重要，可以设置为0xFF，同时也会收到6个字节，第一个字节固定是状态寄存器的值，后面5个字节才是实际读取的字节。写入寄存器的操作同理，比如对一个寄存器写入5个字节，就会发送6个字节，同时收到6个字节，但是收到的后面5个字节都没有意义（经过测试基本都是0）。</p>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>主要有四种模式，可以通过设置寄存器和控制引脚来切换模式，具体可以看Datasheet 6.1.1的状态图。</p>
<h4 id="掉电模式（Power-Down-Mode）"><a href="#掉电模式（Power-Down-Mode）" class="headerlink" title="掉电模式（Power Down Mode）"></a>掉电模式（Power Down Mode）</h4><p>注意这并不是没有电的情况，这是模块上电后的默认模式，此时CONFIG寄存器的PWR_UP = 0，可以读取和设置寄存器，正如其名，功耗很低。</p>
<h4 id="待机模式（Standby-Modes）"><a href="#待机模式（Standby-Modes）" class="headerlink" title="待机模式（Standby Modes）"></a>待机模式（Standby Modes）</h4><p>待机模式有两个</p>
<h5 id="待机模式1（Standby-I-Mode）"><a href="#待机模式1（Standby-I-Mode）" class="headerlink" title="待机模式1（Standby-I Mode）"></a>待机模式1（Standby-I Mode）</h5><p>在掉电模式下设置PWR_UP = 1即可进入待机模式1，这是我们使用模块收发的时候主要使用的模式。</p>
<h5 id="待机模式2（Standby-II-Mode）"><a href="#待机模式2（Standby-II-Mode）" class="headerlink" title="待机模式2（Standby-II Mode）"></a>待机模式2（Standby-II Mode）</h5><p>这个模式需要从待机模式1进入。这个有点待发送那味，当发送缓冲区为空且PRIM_RX = 0，CE拉高的时候会进入这个模式，在这个模式下如果有数据填入发送缓冲区则会进入到发送模式，发送完毕后发送缓冲区清空，如果没有拉低CE则又会回到这个模式，否则回到待机模式1。</p>
<p>也就是说在这个模式下只要填入发送缓冲区，数据就会被发送出去。</p>
<h4 id="接收模式（RX-Mode）"><a href="#接收模式（RX-Mode）" class="headerlink" title="接收模式（RX Mode）"></a>接收模式（RX Mode）</h4><p>用于接收数据。</p>
<p>在待机模式1下，CE拉高，PRIM_RX = 1即可进入这个模式。</p>
<p>一般来说这个模式下只能接收数据，但是Datasheet中提到</p>
<blockquote>
<p>However, if the automatic protocol features (Enhanced ShockBurstTM) in the baseband protocol engine are enabled, the nRF24L01+ can enter other modes in order to execute the protocol.</p>
</blockquote>
<p>说实话不太理解它的意思，如果有大佬能翻译一下实在感激不尽。</p>
<h4 id="发送模式（TX-Mode）"><a href="#发送模式（TX-Mode）" class="headerlink" title="发送模式（TX Mode）"></a>发送模式（TX Mode）</h4><p>用于发送数据。</p>
<p>在待机模式1下，CE拉高，PRIM_RX = 0，发送缓冲区存在数据时即可进入这个模式。</p>
<h3 id="编程指北"><a href="#编程指北" class="headerlink" title="编程指北"></a>编程指北</h3><h4 id="检测模块是否存在"><a href="#检测模块是否存在" class="headerlink" title="检测模块是否存在"></a>检测模块是否存在</h4><p>一般的操作是写入5个字节的指定到TX_ADDR寄存器，然后再读取出来看是否一致。没什么难的，干就完事了。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>首先要拉低CE，然后主要就是设置寄存器</p>
<h5 id="CONFIG-0x00"><a href="#CONFIG-0x00" class="headerlink" title="CONFIG - 0x00"></a>CONFIG - <code>0x00</code></h5><p>设置IRQ引脚行为，建议启用所有中断源，启用CRC校验，1字节，PWR_UP = 1，也就是<code>0x0A</code>。</p>
<h5 id="EN-AA-0x01"><a href="#EN-AA-0x01" class="headerlink" title="EN_AA - 0x01"></a>EN_AA - <code>0x01</code></h5><p>用于配置Enhanced ShockBurst，需要哪个通道就开哪个，默认全开，但是如果只是一对一通信的话只要开两个就好了，比如只开通道0和1，设置为<code>0x03</code>即可。</p>
<h5 id="EN-RXADDR-0x02"><a href="#EN-RXADDR-0x02" class="headerlink" title="EN_RXADDR - 0x02"></a>EN_RXADDR - <code>0x02</code></h5><p>启用接收的通道，默认只开了通道1和通道0，即<code>0x03</code>。</p>
<h5 id="SETUP-AW-0x03"><a href="#SETUP-AW-0x03" class="headerlink" title="SETUP_AW - 0x03"></a>SETUP_AW - <code>0x03</code></h5><p>设置地址长度，默认是5字节（<code>0x03</code>）。</p>
<h5 id="SETUP-RETR-0x04"><a href="#SETUP-RETR-0x04" class="headerlink" title="SETUP_RETR - 0x04"></a>SETUP_RETR - <code>0x04</code></h5><p>设置自动重发次数（3次）和重发延迟时间（500微秒）（<code>0x13</code>）。</p>
<p>Datasheet的注释中提到如果要使用250kbps速率，则需要把重发延迟时间设置为500微秒或更高，具体可以看7.4.2节。</p>
<h5 id="RF-CH-0x05"><a href="#RF-CH-0x05" class="headerlink" title="RF_CH - 0x05"></a>RF_CH - <code>0x05</code></h5><p>射频的频段，默认是<code>0x02</code>，也就是2.402GHZ。</p>
<h5 id="RF-SETUP-0x06"><a href="#RF-SETUP-0x06" class="headerlink" title="RF_SETUP - 0x06"></a>RF_SETUP - <code>0x06</code></h5><p>射频的速率和功率，具体去看Datasheet吧，我这里使用250kbps速率，0dbm功率，<code>0x26</code>。</p>
<h5 id="RX-ADDR-P0-0x0A"><a href="#RX-ADDR-P0-0x0A" class="headerlink" title="RX_ADDR_P0 - 0x0A"></a>RX_ADDR_P0 - <code>0x0A</code></h5><p>接收通道0的接收地址，最长5字节，如果要使用Enhanced ShockBurst就得设置成和发送地址一样。</p>
<h5 id="RX-ADDR-P1-0x0B"><a href="#RX-ADDR-P1-0x0B" class="headerlink" title="RX_ADDR_P1 - 0x0B"></a>RX_ADDR_P1 - <code>0x0B</code></h5><p>接收通道1的地址在开启Enhanced ShockBurst的情况下一般用这个通道来接收数据。</p>
<h5 id="TX-ADDR-0x10"><a href="#TX-ADDR-0x10" class="headerlink" title="TX_ADDR - 0x10"></a>TX_ADDR - <code>0x10</code></h5><p>发送地址，同样是自己设置。</p>
<h5 id="DYNPD-0x1C"><a href="#DYNPD-0x1C" class="headerlink" title="DYNPD - 0x1C"></a>DYNPD - <code>0x1C</code></h5><p>接收通道动态载荷长度（Dynamic Payload Length），我们开启通道1和通道0，<code>0x03</code>。</p>
<h5 id="FEATURE-0x1D"><a href="#FEATURE-0x1D" class="headerlink" title="FEATURE - 0x1D"></a>FEATURE - <code>0x1D</code></h5><p>三个设置项</p>
<ul>
<li>EN_DPL，启用动态载荷长度（Dynamic Payload Length），Datasheet中这里写错了，bit应该是1，而不是2。</li>
<li>EN_ACK_PAY，启用Payload with ACK。</li>
<li>EN_DYN_ACK，启用W_TX_PAYLOAD_NOACK命令。</li>
</ul>
<p>默认是<code>0x00</code>，我们开启EN_DPL和EN_ACK_PAY，<code>0x06</code>。</p>
<h4 id="发送和接收"><a href="#发送和接收" class="headerlink" title="发送和接收"></a>发送和接收</h4><h5 id="Enhanced-ShockBurst"><a href="#Enhanced-ShockBurst" class="headerlink" title="Enhanced ShockBurst"></a>Enhanced ShockBurst</h5><p>最好先了解<strong>Enhanced ShockBurst</strong>是个什么玩意，怎么操作。后面的内容以Enhanced ShockBurst为基本，因为这个很好用。</p>
<p>大多数的无线通信在硬件上是半双工，当然我们可以通过软件方法抽象成全双工。Enhanced ShockBurst是ShockBurst的增强版，它自动帮我们完成应答（ACK）过程，同时接收端还可以设置应答的载荷（通过命令W_ACK_PAYLOAD来写入，发送方收到应答之后从通道0读取载荷）。要使用Enhanced ShockBurst，需要接收和发送两方都进行设置，</p>
<ul>
<li>发送方配置ARC&gt;0（默认为3），同时将通道0的接收地址设置为与发送地址相同，通过W_TX_PAYLOAD命令写入待发送数据，而不是W_TX_PAYLOAD_NOACK。</li>
<li>接收方配置EN_AA。</li>
</ul>
<h5 id="动态长度（Dynamic-Payload-Length）"><a href="#动态长度（Dynamic-Payload-Length）" class="headerlink" title="动态长度（Dynamic Payload Length）"></a>动态长度（Dynamic Payload Length）</h5><p>一般单词发送的包可以携带32字节的载荷，但有时候我们并不需要这么长的载荷，所以可以通过这个功能来减少损耗。</p>
<p>需要发送和接收双方都要开启EN_DPL，接收方还要配置DYNPD寄存器开启各个通道的动态长度。</p>
<p>接收方可以用命令R_RX_PL_WID来读取FIFO中数据的实际长度。</p>
]]></content>
      <categories>
        <category>嵌入式开发</category>
        <category>NRF24L01</category>
      </categories>
      <tags>
        <tag>嵌入式开发</tag>
        <tag>SPI</tag>
        <tag>NRF24L01</tag>
      </tags>
  </entry>
  <entry>
    <title>TimeMachine服务器-netatalk</title>
    <url>/2019/07/11/TimeMachine%E6%9C%8D%E5%8A%A1%E5%99%A8-netatalk/</url>
    <content><![CDATA[<p>其实真的不麻烦，也不用samba什么的，直接一个netatalk就完了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ubuntu下</span></span><br><span class="line">sudo apt-get install -y netatalk</span><br></pre></td></tr></table></figure>

<p>然后编辑<code>/etc/netatalk/AppleVolumes.default</code>，把带有<code>&quot;Home Directory&quot;</code>的那行去掉（应该是180行），加上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;你用来备份的目录&gt;     &quot;TimeMachine&quot;   volsizelimit:600000     options:tm</span><br></pre></td></tr></table></figure>

<p>然后重启一下netatalk</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service netatalk restart</span><br></pre></td></tr></table></figure>

<p>或者用<code>systectl</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart netatalk</span><br></pre></td></tr></table></figure>

<p>做好之后在Finder中按<code>command+k</code>，输入<code>afp://&lt;你的服务器ip&gt;</code>，输入服务器用户名密码，如果顺利的话就能在TimeMachine设置里面看到这个磁盘了。</p>
]]></content>
      <categories>
        <category>GNU/Linux</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>PMW3901</title>
    <url>/2019/06/12/PMW3901/</url>
    <content><![CDATA[<p>这里记录下PMW3901的应用笔记，开发平台为真特么爽的树莓派，使用spidev这个python库。</p>
<p>PMW3901是一个性能还不错的硬件光流方案，来自Pixart厂，使用SPI协议传输，我自己试了下跑个100Hz简直不要太轻松，虽然精度比起OpenCV里面的各种算法差了不少，但是好在小巧而且不需要高性能处理器。（虽然我们今天使用的树莓派就算是性能挺高的处理器了。。。）</p>
<h2 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h2><p>当然是接到SPI上啦，参考<a href="https://pinout.xyz/pinout/spi">这里</a>。片选我接的是CE0，当然你要接到CE1也可以，代码稍微改一下就好。注意使用的是SPI0而不是SPI1，因为我们使用的是MODE3，而恰好树莓派的SPI1对MODE3有bug，截止目前这个bug仍未修复。</p>
<h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><p>我使用的是raspbian操作系统，spi设备会被挂载到<code>/dev/spidev*.*</code>。你可以用以下命令检查</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /dev/spidev*</span><br></pre></td></tr></table></figure>

<p>如果是其他的操作系统，我不保证能正常运行。</p>
<h3 id="安装spidev"><a href="#安装spidev" class="headerlink" title="安装spidev"></a>安装<code>spidev</code></h3><p>如果你还没有安装的话，可以执行下面的命令来安装。我们使用python3，所以这里是<code>pip3</code>，如果你仍然在使用python2，我建议你现在更换。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pip3 install spidev</span><br></pre></td></tr></table></figure>

<h2 id="协议分析"><a href="#协议分析" class="headerlink" title="协议分析"></a>协议分析</h2><p>开发一个芯片必备的是什么？datasheet！</p>
<p>对于PMW3901，我们同样需要它的datasheet。比较可惜的是，Pixart似乎不太情愿提供，反正我找了很久都没找到下载datasheet的按钮，后来还是找淘宝卖家要的。</p>
]]></content>
      <categories>
        <category>航模</category>
        <category>飞控</category>
        <category>光流</category>
      </categories>
      <tags>
        <tag>光流</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2360</title>
    <url>/2020/04/25/UESTC-2360/</url>
    <content><![CDATA[<blockquote>
<p>关键字：括号匹配；栈；</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>括号匹配，直接上栈就完事了。首先判断输入的符号是<code>(</code>还是<code>)</code>，如果是前者则入栈，后者先判断栈是否为空，空则<code>ans+=1</code>，不空的话出栈，最后栈内剩余的是没有被匹配的，所以答案是<code>ans</code>加上栈内元素数量。时间复杂度$o(n)$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                st.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// ) matches a (</span></span><br><span class="line">                <span class="keyword">if</span> (st.empty()) &#123;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans + st.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.empty())&#123;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实不用STL的<code>stack</code>也可以，只需要记录有多少个<code>(</code>，应该会更快，毕竟栈内只会有着一种符号，我以为这样写会TLE，没想到居然过了，可能是训练题比较水吧。如果是多种括号的匹配，比如<code>()[]&#123;&#125;</code>的组合，那应该只能用栈。</p>
]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>数据结构</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>Stack</tag>
        <tag>数据结构</tag>
        <tag>括号匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2361</title>
    <url>/2020/05/05/UESTC-2361/</url>
    <content><![CDATA[<blockquote>
<p>关键字：并查集；</p>
</blockquote>
<h2 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h2><p>这个方法来自于判断链表中是否存在环，原理很直观，就是加入一个移动较慢的指针（一般是快指针速度的一半），如果链表中有环的话，就会导致两个指针出发了一段时间后“撞”在一起。所以只要在出发后判断两个指针是否相等即可确定链表中是否有环。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>并查集模板题，快慢指针法判断是否成环，再加个路径压缩就完事。复杂度$o(n)$，这题限时是200ms，太极限了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">&quot;O3&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> isLoop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSet</span><span class="params">(<span class="keyword">int</span> fast, <span class="keyword">int</span> slow, <span class="keyword">bool</span> moveSlow = <span class="literal">false</span>, <span class="keyword">int</span> step = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fast == a[fast]) &#123;</span><br><span class="line">        isLoop = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fast = a[fast];</span><br><span class="line">        <span class="keyword">if</span> (moveSlow) &#123;</span><br><span class="line">            slow = a[slow];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (step &amp;&amp; fast == slow) &#123;</span><br><span class="line">                <span class="comment">// loop</span></span><br><span class="line">                isLoop = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findSet(fast, slow, !moveSlow, step + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSet</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == a[x]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = a[x];</span><br><span class="line">    a[x] = x;</span><br><span class="line">    mergeSet(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// std::cin.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; a[i];</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        <span class="keyword">if</span> (a[i] == i) &#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == i) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        findSet(i, i);</span><br><span class="line">        <span class="keyword">if</span> (isLoop) &#123;</span><br><span class="line">            <span class="comment">// new loop</span></span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// compress</span></span><br><span class="line">        mergeSet(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的<code>findSet</code>函数用于查找根结点，成环的话会返回环上某一点，具体是哪个这里不展开说，同时会标记<code>isLoop</code>变量。</p>
<p><code>mergeSet</code>用于路径压缩，如果我们只关心一个结点的根结点，在<code>findSet</code>完成之后直接把根结点设为它的父结点，这样如果以后还有结点在<code>findSet</code>过程中路过这个结点就可以快速找到根结点了，再引申一下，如果将路径上所有的结点都重新设置父亲结点，就可以加快经过那些结点的<code>findSet</code>。再优化一下，<code>ans+=1</code>之后，这个结点的根结点其实也不重要了，它的子结点必然不需要<code>ans+=1</code>，所以直接把路径上每个结点都设为根节点，速度又能提升一些。</p>
]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2362</title>
    <url>/2020/05/05/UESTC-2362/</url>
    <content><![CDATA[<blockquote>
<p>关键字：前缀和；逆序对；树状数组；</p>
</blockquote>
<p>这题实属有丶东西。</p>
<p>首先确定分母，显然$l$和$r$共有$\frac{n(n+1)}{2}$种取值，所以分母就是那么多。</p>
<p>这题需要算法的部分主要在分子，即有多少个$(l,r)$对使得平均值小于等于$k$。</p>
<p>首先为了方便，我们将输入的每个元素全部减去$k$，这样只需要判断$[l,r]$区间上的和是否小于等于0即可即可，于是很自然地，我们可以算一下前缀和，这里用$S_i$表示。</p>
<p>那么对于$[l,r]$区间上的和，我们可以很方便地用$A=S_r-S_{l-1}$求出来，显然我们知道，$r\ge l$，而$l$和$r$都是整数，所以有$r&gt;l-1$，现在联立一下，得到<br>$$<br>\cases{<br>S_r-S_{l-1}\le0 \<br>r&gt;l-1<br>}<br>$$<br>这不就是妥妥的逆序对吗？也就是说，只要求出$S_i$的逆序对即可。</p>
<p>一般求逆序对可以暴力（时间复杂度$O(n^2)$）、归并排序（时间复杂度$O(n\log_2n)$）、树状数组（时间复杂度$O(n\log_2n)$），因为是数据结构专题，很自然地就选树状数组了。</p>
<p>求逆序对的思路参照<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">leetcode 面试题51</a>，首先对输入的序列，可以从后向前遍历，设当前遍历的元素是$a_i$，那么我们只需要找到在$a_i$之后且小于等于$a_i$的元素个数。具体来说，我们可以用一个桶，并求出桶中$1$到$a_i$的区间和，然后另第$a_i$个元素自增即可，因为桶需要更新，所以可以用树状数组或者线段树来完成，查询和更新的复杂度都是$O(\log n)$。</p>
<p>另外要注意，$a_i$的值可能很大，在题目中范围是1e9，然而我们并没有那么大的内存去开1e9长度的数组作为桶。实际上我们只要求逆序对的个数，对逆序对的具体值并不关心，只要他们的大小关系没问题就行，所以我们可以使用离散化算法，使得$a_i$的值缩小到$n$，具体做法是先拷贝到另一个数组，然后排序，再二分查找回来，就可以将原数组映射到大小为$n$的值域内。离散化算法的复杂度是$O(n\log n)$。</p>
<p>最后的输出就没啥了，gcd求最大公约数，分子分母都除以最法公约数，加个斜杠输出。</p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ul>
<li>int会溢出。</li>
<li>答案为0单独判断，输出<code>0/1</code>。</li>
<li>在求逆序对的时候如果$l-1$从1开始，那么$l$就得从0开始，所以得注意前缀和数组第一个元素，要么在前缀和数组头部添一个0，要么单独遍历$l=0$的情况。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">&quot;O3&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAX = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a == <span class="number">0</span> ? b : gcd(b % a, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; tree;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BIT(<span class="keyword">long</span> <span class="keyword">long</span> _n) : n(_n), tree(_n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询前缀和</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            ret += tree[x];</span><br><span class="line">            x -= lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自增1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">            tree[x]++;</span><br><span class="line">            x += lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    vector&lt;long long&gt; sum(n + 1), arr(n + 1);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        arr[i] = tmp - k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// prefix sum</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum[i] = arr[i] + sum[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求逆序对</span></span><br><span class="line">    <span class="comment">// 离散化</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; tmpArr = sum;</span><br><span class="line">    <span class="comment">// for l=1</span></span><br><span class="line">    sort(tmpArr.begin(), tmpArr.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum[i] = lower_bound(tmpArr.begin(), tmpArr.end(), sum[i]) - tmpArr.begin() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 树状数组统计逆序对</span></span><br><span class="line">    <span class="function">BIT <span class="title">bit</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ans += bit.query(sum[i]);</span><br><span class="line">        bit.update(sum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// return 0;</span></span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;0/1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> g = gcd(ans, n * (n + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans / g &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; n * (n + <span class="number">1</span>) / <span class="number">2</span> / g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试例生成（Python）"><a href="#测试例生成（Python）" class="headerlink" title="测试例生成（Python）"></a>测试例生成（Python）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c</span>(<span class="params">n, k</span>):</span></span><br><span class="line">     a = [<span class="built_in">str</span>(random.randint(<span class="number">1</span>,<span class="number">2</span> * k)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">     f = <span class="built_in">open</span>(<span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">     f.write(<span class="string">&quot;&#123;&#125; &#123;&#125;\r\n&#123;&#125;\r\n&quot;</span>.<span class="built_in">format</span>(n, k, <span class="string">&quot; &quot;</span>.join(a)))</span><br><span class="line">     f.close()</span><br></pre></td></tr></table></figure>

<h3 id="暴力法（用于验证）"><a href="#暴力法（用于验证）" class="headerlink" title="暴力法（用于验证）"></a>暴力法（用于验证）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">&quot;O3&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAX = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a == <span class="number">0</span> ? b : gcd(b % a, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    vector&lt;long long&gt; sum(n + 1), arr(n + 1);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        arr[i] = tmp - k;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// prefix sum</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum[i] = arr[i] + sum[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暴力</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">1</span>; l &lt; n; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> r = l + <span class="number">1</span>; r &lt;= n; r++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum[r] - sum[l - <span class="number">1</span>] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// return 0;</span></span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;0/1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> g = gcd(ans, n * (n + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans / g &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; n * (n + <span class="number">1</span>) / <span class="number">2</span> / g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>数据结构</tag>
        <tag>前缀和</tag>
        <tag>逆序对</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2363</title>
    <url>/2020/05/07/UESTC-2363/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>利姆露现在想知道一个奇怪魔法序列的含义，于是她把这个任务交给了大贤者。</p>
<p>这个魔法序列由 n<em>n</em> 个字符组成，仅包含 L，R，小写拉丁字母和括号（即 ‘(’ 和 ‘)’），表达对一个空白字符串的操作（因为是空白字符串，所以最初操作位置在哪里都一样），其中</p>
<ol>
<li>L 表示当前操作位置左移一位。</li>
<li>R 表示当前操作位置右移一位。</li>
<li>其余任何小写拉丁字母或括号表示将当前操作位置修改为该字符。</li>
</ol>
<p>大贤者知道这个操作产生的序列对应一个魔法，当序列中括号不合法时，魔法会失败；而括号序列合法时，括号的最大嵌套重数就是魔法的强度。</p>
<p>现在大贤者想知道这个过程中每一步产生的序列对应的魔法是一个失败的魔法还是一个成功的魔法，若是一个成功的魔法，则其威力是多少？你能够帮忙完成这件事吗？</p>
<p>（不知道怎么概括，直接复制粘贴了）</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>参考出题人给的题解PPT。</p>
<p>主要是维护一个编辑器，同时能快速得到字符串中括号是否匹配，以及括号的嵌套层数。</p>
<p>我一开始看到括号匹配就想到栈，但是每次都遍历一次铁定超时。实际上我们只需要对字符串求一个前缀和，<code>(</code>加1，<code>)</code>减1，如果前缀和数组中有小于0的数或者最后一位不为0（即左右括号数量不相等）则非法，前缀和数组的最大值则是最大嵌套数。所以只需要维护一个前缀和数组，以及最大值和最小值即可，原数组的单点修改会导致前缀和数组的区间修改，用线段树可以实现复杂度$O(\log_2 n)$完成，查询最大值和最小值也是。所以总的复杂度是$O(n\log_2n)$。</p>
<p>因为光标可能会移动到左边，所以可以从数组中间开始。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>因为没有发生WA，而只有RE（数组越界），所以就没写暴力验证。</p>
<p>RE的原因是数组开小了，$n$最大是1e6，所以数组应该要开到2e6长度。</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(&quot;O3&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAX = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> arr[MAX * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="keyword">int</span> val, min, max, lazy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node tree[MAX * <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> treeIndex = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;node = tree[treeIndex];</span><br><span class="line">    node.left = left;</span><br><span class="line">    node.right = right;</span><br><span class="line">    <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        build(left, mid, treeIndex * <span class="number">2</span>);</span><br><span class="line">        build(mid + <span class="number">1</span>, right, treeIndex * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> val, <span class="keyword">int</span> treeIndex = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;node = tree[treeIndex];</span><br><span class="line">    <span class="keyword">if</span> (node.left == node.right) &#123;</span><br><span class="line">        node.val += val;</span><br><span class="line">        node.max = node.val;</span><br><span class="line">        node.min = node.val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left &gt;= left &amp;&amp; node.right &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 子集</span></span><br><span class="line">        node.lazy += val;</span><br><span class="line">        node.max += val;</span><br><span class="line">        node.min += val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (node.left + node.right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= left) &#123;</span><br><span class="line">        update(left, right, val, treeIndex * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; right) &#123;</span><br><span class="line">        update(left, right, val, treeIndex * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    node.max = max(tree[treeIndex * <span class="number">2</span>].max, tree[treeIndex * <span class="number">2</span> + <span class="number">1</span>].max) + node.lazy;</span><br><span class="line">    node.min = min(tree[treeIndex * <span class="number">2</span>].min, tree[treeIndex * <span class="number">2</span> + <span class="number">1</span>].min) + node.lazy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> treeIndex = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;node = tree[treeIndex];</span><br><span class="line">    <span class="keyword">if</span> (node.left == node.right) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (node.left + node.right) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> 优化一波？</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.lazy + query(pos, treeIndex * <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node.lazy + query(pos, treeIndex * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> arrCursor = MAX;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rMax = arrCursor + n + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> lMin = arrCursor - n + <span class="number">5</span>;</span><br><span class="line">    build(lMin, rMax);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">            arrCursor -= <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">            arrCursor += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> origin = arr[arrCursor];</span><br><span class="line">            arr[arrCursor] = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (origin == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// +2</span></span><br><span class="line">                    update(arrCursor, rMax, <span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (origin != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// +1</span></span><br><span class="line">                    update(arrCursor, rMax, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (origin == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// -2</span></span><br><span class="line">                    update(arrCursor, rMax, <span class="number">-2</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (origin != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                    update(arrCursor, rMax, <span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (origin == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// -1</span></span><br><span class="line">                    update(arrCursor, rMax, <span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (origin == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// +1</span></span><br><span class="line">                    update(arrCursor, rMax, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree[<span class="number">1</span>].min &gt;= <span class="number">0</span> &amp;&amp; query(rMax) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; tree[<span class="number">1</span>].max &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试例生成（Python）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d</span>(<span class="params">n, filename=<span class="string">&#x27;in&#x27;</span></span>):</span></span><br><span class="line">    n = <span class="built_in">int</span>(n)</span><br><span class="line">    arr = [<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">    random.shuffle(arr)</span><br><span class="line">    a = [arr[random.randint(<span class="number">0</span>, <span class="number">4</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    fi = <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    fi.write(<span class="string">&quot;&#123;&#125;\r\n&#123;&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        n, <span class="string">&quot;&quot;</span>.join(a)</span><br><span class="line">    ))</span><br><span class="line">    fi.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2364</title>
    <url>/2020/05/05/UESTC-2364/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给一个$n$行$m$列的数据，找出其中</p>
<ul>
<li>尽可能大</li>
<li>边长为奇数</li>
<li>中心元素能被其他元素整除</li>
</ul>
<p>的正方形。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>出题人的PPT题解上写的挺清楚了，上述条件成立的情况下，则中心元素一定是正方形内所有元素中最小的，而且正方形内所有元素的最大公约数也是中心元素。</p>
<p>暴力枚举每个点就行。我们可以用二维ST表来实现复杂度$O(1)$求最小值，$O(\log_2 n)$求区域内的最大公约数（GCD）。下标从$0$开始的话，只需要从$(1,1)$枚举到$(n-1,m-1)$即可，因为边缘上的数不会有正方形。</p>
<p>对于每个枚举，首先确定忽略条件3时最大能取的正方形的边长是多少，比如$(i,j)$的话最大边长是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">min(min(i, n - i - <span class="number">1</span>), min(j, m - j - <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>然后通过二分查找确定条件3下的最大边长。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="WA-AC代码"><a href="#WA-AC代码" class="headerlink" title="WA AC代码"></a><del>WA</del> AC代码</h3><p><del>我真希望在这里写的是”AC代码”，可惜现在还是卡在第8个测试点。</del></p>
<p>5.4 20:35 update: 因为把第102行的<code>i</code>写成了<code>j</code>导致一直卡在第8个test case而自闭。关于错误的位置可以看暴力验证代码的第100行（也就是说那个暴力程序是错误的）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">&quot;O3&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAX = <span class="number">2e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> st[<span class="number">500</span>][<span class="number">500</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> stGCD[<span class="number">500</span>][<span class="number">500</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> qmin(a, b, c, d) min(min(a,b),min(c,d))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gcd(y % x, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> qgcd(a, b, c, d) gcd(gcd(a, b), gcd(c, d))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pow2[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">queryMin</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> midX, <span class="keyword">long</span> <span class="keyword">long</span> midY, <span class="keyword">long</span> <span class="keyword">long</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = log2(len * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> qmin(st[midX - len][midY - len][k],</span><br><span class="line">                st[midX - len][midY + len - pow2[k] + <span class="number">1</span>][k],</span><br><span class="line">                st[midX + len - pow2[k] + <span class="number">1</span>][midY - len][k],</span><br><span class="line">                st[midX + len - pow2[k] + <span class="number">1</span>][midY + len - pow2[k] + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">queryGCD</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> midX, <span class="keyword">long</span> <span class="keyword">long</span> midY, <span class="keyword">long</span> <span class="keyword">long</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = log2(len * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> qmin(stGCD[midX - len][midY - len][k],</span><br><span class="line">                stGCD[midX - len][midY + len - pow2[k] + <span class="number">1</span>][k],</span><br><span class="line">                stGCD[midX + len - pow2[k] + <span class="number">1</span>][midY - len][k],</span><br><span class="line">                stGCD[midX + len - pow2[k] + <span class="number">1</span>][midY + len - pow2[k] + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// n行m列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">            st[i][j][<span class="number">0</span>] = a[i][j];</span><br><span class="line">            stGCD[i][j][<span class="number">0</span>] = a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    <span class="keyword">int</span> len = min(n, m);</span><br><span class="line">    pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">        pow2[k] = pow2[k - <span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> log2len = log2(len) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= log2len; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + pow2[k] &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + pow2[k] &lt;= m; j++) &#123;</span><br><span class="line">                st[i][j][k] = qmin(st[i][j][k - <span class="number">1</span>],</span><br><span class="line">                                   st[i][j + pow2[k - <span class="number">1</span>]][k - <span class="number">1</span>],</span><br><span class="line">                                   st[i + pow2[k - <span class="number">1</span>]][j][k - <span class="number">1</span>],</span><br><span class="line">                                   st[i + pow2[k - <span class="number">1</span>]][j + pow2[k - <span class="number">1</span>]][k - <span class="number">1</span>]);</span><br><span class="line">                stGCD[i][j][k] = qgcd(stGCD[i][j][k - <span class="number">1</span>],</span><br><span class="line">                                      stGCD[i][j + pow2[k - <span class="number">1</span>]][k - <span class="number">1</span>],</span><br><span class="line">                                      stGCD[i + pow2[k - <span class="number">1</span>]][j][k - <span class="number">1</span>],</span><br><span class="line">                                      stGCD[i + pow2[k - <span class="number">1</span>]][j + pow2[k - <span class="number">1</span>]][k - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="comment">// 确定可以取的范围</span></span><br><span class="line">            <span class="keyword">int</span> maxLen = qmin(i, n - i - <span class="number">1</span>, j, m - j - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 二分查找</span></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">1</span>, r = maxLen + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j] == queryMin(i, j, mid) &amp;&amp; a[i][j] == queryGCD(i, j, mid)) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans == l - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; l - 1 &lt;&lt; endl;</span></span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l - <span class="number">1</span> &gt; ans) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; l - 1 &lt;&lt; endl;</span></span><br><span class="line">                ans = l - <span class="number">1</span>;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; n * m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ans * <span class="number">2</span> + <span class="number">1</span>) * (ans * <span class="number">2</span> + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试例生成（Python）"><a href="#测试例生成（Python）" class="headerlink" title="测试例生成（Python）"></a>测试例生成（Python）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">e</span>(<span class="params">n, m, <span class="built_in">max</span>=<span class="number">1e9</span>, filename=<span class="string">&#x27;in&#x27;</span></span>):</span></span><br><span class="line">    a = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        a.append(<span class="string">&quot;\t&quot;</span>.join([<span class="built_in">str</span>(random.randint(<span class="number">1</span>, <span class="built_in">max</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m)]))</span><br><span class="line">    f = <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&quot;&#123;&#125; &#123;&#125;\r\n&#123;&#125;\r\n&quot;</span>.<span class="built_in">format</span>(n, m, <span class="string">&quot;\r\n&quot;</span>.join(a)))</span><br><span class="line">    f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="暴力验证"><a href="#暴力验证" class="headerlink" title="暴力验证"></a>暴力验证</h3><p>这个其实不能算完全暴力，因为还是用了ST表，只是没有用二分查找。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">&quot;O3&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAX = <span class="number">2e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">500</span>][<span class="number">500</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> stGCD[<span class="number">500</span>][<span class="number">500</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> qmin(a, b, c, d) min(min(a,b),min(c,d))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gcd(y % x, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> qgcd(a, b, c, d) gcd(gcd(a, b), gcd(c, d))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pow2[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryMin</span><span class="params">(<span class="keyword">int</span> midX, <span class="keyword">int</span> midY, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = log2(len * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> qmin(st[midX - len][midY - len][k],</span><br><span class="line">                st[midX - len][midY + len - pow2[k] + <span class="number">1</span>][k],</span><br><span class="line">                st[midX + len - pow2[k] + <span class="number">1</span>][midY - len][k],</span><br><span class="line">                st[midX + len - pow2[k] + <span class="number">1</span>][midY + len - pow2[k] + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryGCD</span><span class="params">(<span class="keyword">int</span> midX, <span class="keyword">int</span> midY, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = log2(len * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> qmin(stGCD[midX - len][midY - len][k],</span><br><span class="line">                stGCD[midX - len][midY + len - pow2[k] + <span class="number">1</span>][k],</span><br><span class="line">                stGCD[midX + len - pow2[k] + <span class="number">1</span>][midY - len][k],</span><br><span class="line">                stGCD[midX + len - pow2[k] + <span class="number">1</span>][midY + len - pow2[k] + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// n行m列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">            st[i][j][<span class="number">0</span>] = a[i][j];</span><br><span class="line">            stGCD[i][j][<span class="number">0</span>] = a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    <span class="keyword">int</span> len = min(n, m);</span><br><span class="line">    pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">        pow2[k] = pow2[k - <span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> log2len = log2(len) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= log2len; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + pow2[k] &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + pow2[k] &lt;= m; j++) &#123;</span><br><span class="line">                st[i][j][k] = qmin(st[i][j][k - <span class="number">1</span>],</span><br><span class="line">                                   st[i][j + pow2[k - <span class="number">1</span>]][k - <span class="number">1</span>],</span><br><span class="line">                                   st[i + pow2[k - <span class="number">1</span>]][j][k - <span class="number">1</span>],</span><br><span class="line">                                   st[i + pow2[k - <span class="number">1</span>]][j + pow2[k - <span class="number">1</span>]][k - <span class="number">1</span>]);</span><br><span class="line">                stGCD[i][j][k] = qgcd(stGCD[i][j][k - <span class="number">1</span>],</span><br><span class="line">                                      stGCD[i][j + pow2[k - <span class="number">1</span>]][k - <span class="number">1</span>],</span><br><span class="line">                                      stGCD[i + pow2[k - <span class="number">1</span>]][j][k - <span class="number">1</span>],</span><br><span class="line">                                      stGCD[i + pow2[k - <span class="number">1</span>]][j + pow2[k - <span class="number">1</span>]][k - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="comment">// 确定可以取的范围</span></span><br><span class="line">            <span class="keyword">int</span> maxLen = qmin(i, n - i - <span class="number">1</span>, j, m - j - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 暴力查找</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = maxLen; l &gt;= <span class="number">1</span>; l--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j] == queryMin(i, j, l) &amp;&amp; a[i][j] == queryGCD(j, j, l)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ans == l) &#123;</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; l &lt;&lt; endl;</span></span><br><span class="line">                        count += <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; ans) &#123;</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; l &lt;&lt; endl;</span></span><br><span class="line">                        ans = l;</span><br><span class="line">                        count = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; n * m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ans * <span class="number">2</span> + <span class="number">1</span>) * (ans * <span class="number">2</span> + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>数据结构</category>
        <category>ST表</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>数据结构</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2365</title>
    <url>/2020/05/05/UESTC-2365/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你带着大量佣兵回到城市，看到了大量的新赏金任务。你无视其他等级的任务，拿过最高等级的任务列表，发现其任务数量刚好和你的佣兵数量相同，便把它们都接到了自己手上。</p>
<p>每个佣兵都有自己的能力值，每个任务都有能力值要求，能力值大于要求即可完成任务。</p>
<p>你让佣兵们自行选择任务（每人一个），然而，一旦脱离你的命令，他们就无法做出恰当的决策：你看完他们的选择后，发现他们选择的任务既有重复，也有缺漏，还有不少佣兵选择了自己能力不够、无法完成的任务。但你既然已经下令，朝令夕改会影响你的威信。</p>
<p>因此，你决定让他们按照自己的选择从你的手中接任务，如果选择的任务已经被接，则按照任务列表接下一个任务，如果还是被接则继续往下直至接到任务，如果到了最后一个还需继续往下，则从列表的第一个任务开始。（可以把列表理解为环状。列表顺序是既定的，你不可以修改）</p>
<p>不过，还有一件你可以控制的事：你可以决定他们谁先接任务。你需要找到一个最优的顺序，让佣兵完成最多的任务。</p>
<p>请计算最优顺序下可完成的任务数量。</p>
<p>（不知道怎么概括，以上为直接复制粘贴）</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>按照出题人的题解。</p>
<p>首先要保证所有任务都不会被放弃，选择合适的起点即可。首先将每个任务被选中的人数减1求前缀和，找到最小的位置，从该位置的下一个位置作为起点即可保证所有任务都会有人接。</p>
<p>然后遍历每一个任务，查找可以选的人中有没有刚好大于任务需求的，有就让他接，没有就让能力最低的接，二分查找即可。维护最小值可以用<code>std::set</code>，这个容器的第一个元素就是最小的。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>因为并没有发生WA，所以就懒得写暴力验证程序了。</p>
<p>顺便<code>std::set</code>有一个问题，就是容器为空的时候如果调用<code>erase</code>删除元素会发生死循环，而不是RE，到OJ上的表现就是TLE，搞得我老在查是不是常数太大了。</p>
<h3 id="AC代码如下"><a href="#AC代码如下" class="headerlink" title="AC代码如下"></a>AC代码如下</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">&quot;O3&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAX = <span class="number">5e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> choice[MAX];</span><br><span class="line"><span class="keyword">int</span> abilities[MAX];</span><br><span class="line"><span class="keyword">int</span> missionSelectedSum[MAX];</span><br><span class="line"><span class="keyword">int</span> missions[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; ability;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; missionSelected[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="comment">// 找起点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; choice[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; missions[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        missionSelected[choice[i]].insert(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minSum = n + <span class="number">1</span>;</span><br><span class="line">    missionSelectedSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        missionSelectedSum[i] = missionSelectedSum[i - <span class="number">1</span>] + missionSelected[i].size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// find the min sum</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minSum &gt; missionSelectedSum[i]) &#123;</span><br><span class="line">            start = i;</span><br><span class="line">            minSum = missionSelectedSum[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    start += <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 开始了</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it:missionSelected[i]) &#123;</span><br><span class="line">            ability.insert(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ability.empty()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> it = ability.lower_bound(missions[i]);</span><br><span class="line">        <span class="keyword">if</span> (it != ability.end()) &#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            ability.erase(it);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ability.erase(ability.begin());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; start; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it:missionSelected[i]) &#123;</span><br><span class="line">            ability.insert(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ability.empty()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> it = ability.lower_bound(missions[i]);</span><br><span class="line">        <span class="keyword">if</span> (it != ability.end()) &#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            ability.erase(it);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ability.erase(ability.begin());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试例生成（Python）"><a href="#测试例生成（Python）" class="headerlink" title="测试例生成（Python）"></a>测试例生成（Python）</h3><p>这个程序其实不是很优，当<code>max</code>比较大的时候生成会很慢，主要是因为会生成长度为<code>max</code>的数组。如果不用这个方法的话得手写一个能产生唯一数字的序列，懒得再改了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">n, <span class="built_in">max</span>=<span class="number">1e9</span>, filename=<span class="string">&#x27;in&#x27;</span></span>):</span></span><br><span class="line">    n = <span class="built_in">int</span>(n)</span><br><span class="line">    <span class="built_in">max</span> = <span class="built_in">int</span>(<span class="built_in">max</span>)</span><br><span class="line">    choice = [<span class="built_in">str</span>(random.randint(<span class="number">1</span>, n)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    mission = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">max</span>))</span><br><span class="line">    random.shuffle(mission)</span><br><span class="line">    mission = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">str</span>(x), mission[: n]))</span><br><span class="line">    ability = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">max</span>))</span><br><span class="line">    random.shuffle(ability)</span><br><span class="line">    ability = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">str</span>(x), ability[: n]))</span><br><span class="line">    fi = <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    fi.write(<span class="string">&quot;&#123;&#125;\r\n&#123;&#125;\r\n&#123;&#125;\r\n&#123;&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        n, <span class="string">&quot; &quot;</span>.join(choice), <span class="string">&quot; &quot;</span>.join(mission), <span class="string">&quot; &quot;</span>.join(ability)</span><br><span class="line">    ))</span><br><span class="line">    fi.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>数据结构</category>
        <category>set</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>数据结构</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2367</title>
    <url>/2020/05/07/UESTC-2367/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在与拉菲、标枪等人相遇几次之后，綾波心里有些烦恼。一天，她独自在港区玩一个既有趣又能提升自己的能力的游戏，在这个游戏中，她面对一面长墙，墙上排列着 n个点（编号 1∼n），每个点都带有一个数值（可能为负数），同时，还有一个一定要记住的数值 k。</p>
<p>在每一轮游戏中，綾波需要使用鱼雷击中在一个区间（[l,r]）内的所有对 k取模（取<strong>非负最小</strong>剩余）后数值与 c对 k取模（同样取<strong>非负最小</strong>剩余）相等的点，每次击中每个点需要一枚鱼雷。</p>
<p>作为港区鱼雷能力最强的驱逐舰，綾波当然不可能因为没有命中而浪费鱼雷。</p>
<p>每轮游戏结束后，该轮目标区间内的所有点的值将增加 d（d 可能为负数）。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>参照出题人的PPT题解。</p>
<p>先做分块，把数组分成$\sqrt{n}$块，最后一块适当加长。</p>
<p>因为取模对加减符合交换律结合律分配律，所以为了不溢出，每次都取模就好了。</p>
<p>因为取模之后最大为$k$，直接用桶就行，对每个区块放一个长度$k$对桶，记录取模后各个数字的数量。</p>
<p>对于每次查询，如果$l$和$r$在一个区块内就直接暴力，否则对整块的部分直接加上，剩下的暴力。</p>
<p>修改的时候区块可以用一个偏移量来记录，暴力的部分直接加上就行。</p>
<p>每次查询和修改的时间复杂度都是$O(\sqrt n)$，共有$m$次查询，所以总的时间复杂度是$O(m\log_2n)$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>放了个<code>DISPLAY_A</code>宏定义用来在调试的时候输出数组。</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(&quot;O3&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPLAY_A 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAX = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> blockSize, numBlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = x &lt; <span class="number">0</span> ? x % k + k : x % k;</span><br><span class="line">    <span class="keyword">return</span> ans &gt;= k ? ans % k : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBlock</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = (x - <span class="number">1</span>) / blockSize;</span><br><span class="line">    <span class="keyword">if</span> (ans == numBlock) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">int</span> buck[MAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> a[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        a[i] = mod(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分块</span></span><br><span class="line">    numBlock = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    blockSize = n / numBlock;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Block&gt; <span class="title">blocks</span><span class="params">(<span class="number">316</span>)</span></span>;</span><br><span class="line">    blocks[<span class="number">0</span>].left = <span class="number">1</span>;</span><br><span class="line">    blocks[<span class="number">0</span>].right = blockSize;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numBlock; i++) &#123;</span><br><span class="line">        blocks[i].left = blocks[i - <span class="number">1</span>].right + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == numBlock - <span class="number">1</span>) &#123;</span><br><span class="line">            blocks[i].right = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            blocks[i].right = blocks[i].left + blockSize - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numBlock; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i2 = blocks[i].left; i2 &lt;= blocks[i].right; i2++) &#123;</span><br><span class="line">            blocks[i].buck[a[i2]] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="keyword">int</span> m, l, r, c, d;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 分块起点</span></span><br><span class="line">        <span class="comment">// s为l所在区块</span></span><br><span class="line">        <span class="keyword">int</span> s = getBlock(l);</span><br><span class="line">        <span class="comment">// 分块终点</span></span><br><span class="line">        <span class="comment">// e为r所在区块</span></span><br><span class="line">        <span class="keyword">int</span> e = getBlock(r);</span><br><span class="line">        <span class="keyword">if</span> (s == e) &#123;</span><br><span class="line">            <span class="comment">// 在同一个区块，直接遍历吧</span></span><br><span class="line">            <span class="keyword">int</span> t = mod(mod(c) - blocks[s].offset);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] == t) &#123;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                blocks[s].buck[a[i]] -= <span class="number">1</span>;</span><br><span class="line">                a[i] = mod(a[i] + mod(d));</span><br><span class="line">                blocks[s].buck[a[i]] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPLAY_A</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; mod(a[i] + blocks[getBlock(i)].offset) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l != blocks[s].left) &#123;</span><br><span class="line">            <span class="comment">// c % k == (a[i] + offset) % k</span></span><br><span class="line">            t = mod(mod(c) - blocks[s].offset);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= blocks[s].right; i++) &#123;</span><br><span class="line">                <span class="comment">// a[i] + offset == t</span></span><br><span class="line">                <span class="keyword">if</span> (a[i] == t) &#123;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                blocks[s].buck[a[i]] -= <span class="number">1</span>;</span><br><span class="line">                a[i] = mod(a[i] + mod(d));</span><br><span class="line">                blocks[s].buck[a[i]] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r != blocks[e].right) &#123;</span><br><span class="line">            t = mod(mod(c) - blocks[e].offset);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = blocks[e].left; i &lt;= r; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] == t) &#123;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                blocks[e].buck[a[i]] -= <span class="number">1</span>;</span><br><span class="line">                a[i] = mod(a[i] + mod(d));</span><br><span class="line">                blocks[e].buck[a[i]] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            e += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分块查询</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s + <span class="number">1</span>; i &lt; e; i++) &#123;</span><br><span class="line">            ans += blocks[i].buck[mod(mod(c) - blocks[i].offset)];</span><br><span class="line">            blocks[i].offset = mod(blocks[i].offset + mod(d));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPLAY_A</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mod(a[i] + blocks[getBlock(i)].offset) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试例生成（Python）"><a href="#测试例生成（Python）" class="headerlink" title="测试例生成（Python）"></a>测试例生成（Python）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h</span>(<span class="params">n, m, k=random.randint(<span class="params"><span class="number">1</span>, <span class="number">1e5</span></span>), <span class="built_in">max</span>=<span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>, filename=<span class="string">&#x27;in&#x27;</span></span>):</span></span><br><span class="line">    n = <span class="built_in">int</span>(n)</span><br><span class="line">    m = <span class="built_in">int</span>(m)</span><br><span class="line">    k = <span class="built_in">int</span>(k)</span><br><span class="line">    fi = <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    fi.write(<span class="string">&quot;&#123;&#125; &#123;&#125;\r\n&#123;&#125;\r\n&#123;&#125;\r\n&#123;&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        n, k, <span class="string">&quot; &quot;</span>.join([<span class="built_in">str</span>(random.randint(-<span class="built_in">max</span>, <span class="built_in">max</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]),</span><br><span class="line">        m,</span><br><span class="line">        <span class="string">&quot;\r\n&quot;</span>.join([</span><br><span class="line">            <span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                random.randint(<span class="number">1</span>, n // <span class="number">2</span>),</span><br><span class="line">                random.randint(n // <span class="number">2</span>, n),</span><br><span class="line">                random.randint(-<span class="built_in">max</span>, <span class="built_in">max</span>),</span><br><span class="line">                random.randint(-<span class="built_in">max</span>, <span class="built_in">max</span>)</span><br><span class="line">            ) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)</span><br><span class="line">        ])</span><br><span class="line">    ))</span><br><span class="line">    fi.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="暴力验证"><a href="#暴力验证" class="headerlink" title="暴力验证"></a>暴力验证</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">&quot;O3&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPLAY_A 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = x &lt; <span class="number">0</span> ? x % k + k : x % k;</span><br><span class="line">    <span class="keyword">return</span> ans &gt;= k ? ans % k : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> a[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        a[i] = mod(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> l, r, c, d;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        c = mod(c);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == c) &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[i] = mod(a[i] + mod(d));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPLAY_A</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>数据结构</category>
        <category>分块</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>数据结构</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2370</title>
    <url>/2020/05/05/UESTC-2370/</url>
    <content><![CDATA[<blockquote>
<p>关键字：栈；贪心；</p>
</blockquote>
<p><a href="https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/">leetcode 1081</a>差不多，但是有一点区别。这题直接给出了元素的种类，也就是$k$，而leetcode上那题并不直接给出元素种类，但最多是26（小写字母），而这题的$k$高达1e6…</p>
<p>leetcode社区中的题解主要有两种方法：</p>
<ul>
<li>栈+贪心</li>
<li>寻找第一个元素的位置+贪心</li>
</ul>
<p>我在写本题的时候用的第一个方法，第二个应该也可以，但是有点麻烦，它需要$o(1)$的复杂度确定从$i$到最后共有多少种元素，leetcode那题因为最多26种，所以直接位运算就完事，而本题的$k$高达1e6，位运算显然不现实，也可以用前缀和去判断，但是我懒得写，直接第一种完事。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>参照<a href="https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/solution/tan-xin-suan-fa-zhan-wei-yan-ma-python-dai-ma-java/">这个题解</a>。</p>
<p>上面链接的那个幻灯片就很直观了。首先从输入读取一个数字，如果栈是空的则入栈，如果非空则判断能否进入，首先先确定栈内是否存在这个数字，我的做法是用一个<code>marked</code>数组保存已经入栈的数字，如果存在则不处理，不存在则进行下一步，判断栈顶元素是否大于输入的数，如果大于而且栈顶元素还存在于之后的输入中，则出栈并重复这一步骤，直到栈为空或者栈顶小于输入的数，然后入栈，此时就能保证字典序是最小的。</p>
<p>要判断栈顶元素是否还存在于之后的输入中，我的做法是保存每个数字最后出现的位置，这样直接判断当前位置是否小于最后的位置即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">&quot;O3&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> lastPos[MAX];</span><br><span class="line"><span class="keyword">int</span> seq[MAX];</span><br><span class="line"><span class="keyword">int</span> origin[MAX];</span><br><span class="line"><span class="keyword">bool</span> marked[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//std::ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">//std::cin.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// cin &gt;&gt; tmp;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tmp);</span><br><span class="line">        origin[i] = tmp;</span><br><span class="line">        lastPos[tmp] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// stack</span></span><br><span class="line">    <span class="keyword">int</span> stackIter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stackIter == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// insert anyway</span></span><br><span class="line">            seq[stackIter] = origin[i];</span><br><span class="line">            marked[origin[i]] = <span class="literal">true</span>;</span><br><span class="line">            stackIter += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq[stackIter - <span class="number">1</span>] == origin[i] || marked[origin[i]]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stackIter != <span class="number">1</span> &amp;&amp; seq[stackIter - <span class="number">1</span>] &gt;= origin[i] &amp;&amp; i &lt; lastPos[seq[stackIter - <span class="number">1</span>]]) &#123;</span><br><span class="line">                    <span class="comment">// pop</span></span><br><span class="line">                    marked[seq[stackIter - <span class="number">1</span>]] = <span class="literal">false</span>;</span><br><span class="line">                    stackIter -= <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// insert</span></span><br><span class="line">                    seq[stackIter] = origin[i];</span><br><span class="line">                    marked[origin[i]] = <span class="literal">true</span>;</span><br><span class="line">                    stackIter += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stackIter &lt;= k) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Kanade&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; stackIter; i++) &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; seq[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, seq[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试例生成（Python3）"><a href="#测试例生成（Python3）" class="headerlink" title="测试例生成（Python3）"></a>测试例生成（Python3）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">k</span>(<span class="params">n,k</span>):</span></span><br><span class="line">     a = [<span class="built_in">str</span>(random.randint(<span class="number">1</span>, k)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">     f = <span class="built_in">open</span>(<span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">     f.write(<span class="string">&quot;&#123;&#125; &#123;&#125;\r\n&#123;&#125;\r\n&quot;</span>.<span class="built_in">format</span>(n, k, <span class="string">&quot; &quot;</span>.join(a)))</span><br><span class="line">     f.close()</span><br></pre></td></tr></table></figure>

<h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>吐个槽，我在本机上测试1e6的数据量，默认编译器是clang++ 11.0.3 with LLVM，跑了两秒多，换成g++9瞬间提升到0.08秒，绝了。</p>
<p>破案了，macOS上的clang++默认使用libc++，这个库无法通过一般方法关闭流同步，而g++使用的是libstdc++，就没有这个问题。</p>
]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>数据结构</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>Stack</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2374</title>
    <url>/2020/05/05/UESTC-2374/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个环，环上有点，查询从$s$点到最近的大于等于$t$的点的正向距离，没有则输出$-1$。每个点在被查询过后会消失，没消失的点的值每次查询都增加1。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>基本上还是用线段树。</p>
<p>首先用一个<code>grow</code>变量标记过了多少个晚上，长了多少，然后就是用线段树查找出距离$s$最近的大于等于$t-\mathrm{grow}$的点，输出距离完事。</p>
<p>因为有环，所以在查找的时候需要做一些处理来拆环。我的做法比较省事，数组长度为$n$，先查找从$s$到$n$有没有，如果没有就查找从$0$到$s-1$，如果也没有就输出$-1$，有就计算距离输出。</p>
<p>因为是线段树，所以查询复杂度$O(\log_2 n)$，因为有$m$次查询，所以总的时间复杂度是$O(m\log_2 n)$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>因为基本上是一发入魂（手点快了交了十多发完全一样的代码，有些AC有些TLE），所以就没写样例生成程序和暴力验证。</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">&quot;O3&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAX = <span class="number">2e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[MAX];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">bool</span> empty;</span><br><span class="line">    Node *leftSon;</span><br><span class="line">    Node *rightSon;</span><br><span class="line">    Node *father;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node &amp;<span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, Node *father = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;node = *(<span class="keyword">new</span> Node[<span class="number">1</span>]);</span><br><span class="line">    node.left = left;</span><br><span class="line">    node.right = right;</span><br><span class="line">    node.father = father;</span><br><span class="line">    node.empty = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="comment">// leaf</span></span><br><span class="line">        node.max = h[left];</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// build son</span></span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    node.leftSon = &amp;buildTree(left, mid, &amp;node);</span><br><span class="line">    node.rightSon = &amp;buildTree(mid + <span class="number">1</span>, right, &amp;node);</span><br><span class="line">    node.max = max(node.leftSon-&gt;max, node.rightSon-&gt;max);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateFatherMax</span><span class="params">(Node &amp;node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newMax = max(node.leftSon-&gt;max, node.rightSon-&gt;max);</span><br><span class="line">    <span class="keyword">if</span> (newMax != node.max) &#123;</span><br><span class="line">        node.max = newMax;</span><br><span class="line">        <span class="keyword">if</span> (node.father != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            updateFatherMax(*node.father);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryMax</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> t, Node &amp;node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.empty || node.max &lt; t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left == node.right) &#123;</span><br><span class="line">        <span class="comment">// get caught</span></span><br><span class="line">        node.empty = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// update to father</span></span><br><span class="line">        updateFatherMax(*node.father);</span><br><span class="line">        <span class="keyword">return</span> node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftAns = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= node.left &amp;&amp; right &gt;= node.right) &#123;</span><br><span class="line">        <span class="comment">// sub set</span></span><br><span class="line">        leftAns = queryMax(left, right, t, *node.leftSon);</span><br><span class="line">        <span class="keyword">return</span> leftAns != <span class="number">-1</span> ? leftAns : queryMax(left, right, t, *node.rightSon);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (node.left + node.right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= mid) &#123;</span><br><span class="line">        leftAns = queryMax(left, right, t, *node.leftSon);</span><br><span class="line">        <span class="keyword">if</span> (leftAns != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftAns;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt; mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> queryMax(left, right, t, *node.rightSon);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// build tree</span></span><br><span class="line">    <span class="keyword">auto</span> root = buildTree(<span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> s, t;</span><br><span class="line">    <span class="keyword">int</span> grow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        ans = queryMax(s + <span class="number">1</span>, n, t - grow, root);</span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="number">-1</span>) &#123;</span><br><span class="line">            ans = ans - s - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s != <span class="number">0</span>) &#123;</span><br><span class="line">            ans = queryMax(<span class="number">1</span>, s, t - grow, root);</span><br><span class="line">            <span class="keyword">if</span> (ans != <span class="number">-1</span>) &#123;</span><br><span class="line">                ans = (n - s - <span class="number">1</span>) + ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        grow += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2377</title>
    <url>/2020/05/05/UESTC-2377/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>可持久化线段树模板题。</p>
<p>给一段序列，完成两个操作</p>
<ul>
<li>从一个版本新建一个版本，然后单点修改</li>
<li>查询某个版本中某个点的值</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>其实模板题没什么好说的，看下可持久化线段树的工作方式就知道了。<a href="https://oi-wiki.org/ds/persistent-seg/">OI-WiKi</a>真是个好东西。这里还是描述一下怎么做吧。</p>
<p>假如我们要更新原数组中的1号元素，可以从上往下也可以从下往上，我选择的是从上往下。如下图</p>
<p><img src="https://oi-wiki.org/ds/images/persistent-seg.png" alt="img"></p>
<p>可以发现，每次更新一个点，只需要将查询路径中所有的节点都拷贝一份就好了。假如要更新的位置<code>x</code>在当前节点区间的左边，那么新拷贝的节点右儿子不变，左儿子建立一个拷贝，然后递归下去。复杂度和一般线段树一样，查询和修改都是$O(\log_2n)$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><p>居然一发入魂，懒得写测试例生成程序和暴力验证了。</p>
<p>个人觉得不是很优雅，在类中要使用自身的引用会有的麻烦，直接指针了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">&quot;O3&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAX = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点，包含区间左、区间右、当前值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> init = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    Node *leftSon;</span><br><span class="line">    Node *rightSon;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function">Node &amp;<span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;node = *(<span class="keyword">new</span> Node[<span class="number">1</span>]);</span><br><span class="line">    node.left = left;</span><br><span class="line">    node.right = right;</span><br><span class="line">    node.init = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        node.value = a[left];</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    node.leftSon = &amp;buildTree(left, mid);</span><br><span class="line">    node.rightSon = &amp;buildTree(mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node &amp;<span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Node &amp;node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;newNode = *(<span class="keyword">new</span> Node[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;newNode, &amp;node, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (node.left == node.right) &#123;</span><br><span class="line">        newNode.value = y;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新并生成新版本</span></span><br><span class="line">    <span class="keyword">int</span> mid = (node.left + node.right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) &#123;</span><br><span class="line">        <span class="comment">// left</span></span><br><span class="line">        newNode.leftSon = &amp;update(x, y, *node.leftSon);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode.rightSon = &amp;update(x, y, *node.rightSon);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, Node &amp;node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left == node.right) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (node.left + node.right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> query(x, *node.leftSon);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> query(x, *node.rightSon);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node root[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> v, x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// build tree</span></span><br><span class="line">    <span class="keyword">int</span> version = <span class="number">0</span>;</span><br><span class="line">    root[version] = buildTree(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; v &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// update</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line">            version += <span class="number">1</span>;</span><br><span class="line">            root[version] = update(x, y, root[v]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// query</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query(x, root[v]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>主席树</tag>
        <tag>持久化线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2381</title>
    <url>/2020/05/05/UESTC-2381/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>查找长度为$n$的序列中第一个大于等于$k$的元素的位置，并将这个位置的值减去$k$，重复$m$次。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>直接线段树。</p>
<p>首先建立线段树，每个节点保存区间内的最大值，从根节点递归下去即可，复杂度$O(n\log_2n)$。因为只需要单点更新，其实zkw线段树可能更适合，不过这里普通线段树就能过，就没必要了。</p>
<p>查找的过程也很简单，从根节点开始，如果当前节点的<code>max</code>小于$k$直接返回$-1$，如果当前节点是叶子节点就返回自己的索引，否则先找左儿子，左儿子如果是$-1$就返回右儿子，每次查询的复杂度是$O(\log_2n)$。我在自己笔记本上测试，$T=1,n=10^6,m=10^6$情况下的随机数据，基本压着1秒的线，太极限了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><p>有学长说这是主席树（持久化线段树），我也不知道是不是，照着<a href="https://oi-wiki.org/">OI-WiKi</a>写的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">&quot;O3&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAX = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TREE_SUM 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TREE_MAX 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TREE_MIN 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//节点，包含区间和、最大值、最小值、区间左、区间右</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_SUM</span></span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_MAX</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> max;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_MIN</span></span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">&#125;;</span><br><span class="line">Node tree[MAX * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAX];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SegmentTree(<span class="keyword">int</span> _n) : n(_n * <span class="number">4</span>)<span class="comment">/*, tree(_n * 4 + 1)*/</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> _n, <span class="keyword">long</span> <span class="keyword">long</span> *a) : n(_n + <span class="number">1</span>)<span class="comment">/*, tree(_n * 4 + 3)*/</span> &#123;</span><br><span class="line">        build(<span class="number">1</span>, _n, <span class="number">1</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> index, <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> *a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;node = tree[index];</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="comment">// 当前值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_SUM</span></span><br><span class="line">            tree[index].sum = a[left];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_MAX</span></span><br><span class="line">            node.max = a[left];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_MIN</span></span><br><span class="line">            tree[index].min = a[left];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            node.left = left;</span><br><span class="line">            node.right = left;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        build(left, mid, index * <span class="number">2</span>, a);</span><br><span class="line">        build(mid + <span class="number">1</span>, right, index * <span class="number">2</span> + <span class="number">1</span>, a);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_SUM</span></span><br><span class="line">        tree[index].sum = tree[index * <span class="number">2</span>].sum + tree[index * <span class="number">2</span> + <span class="number">1</span>].sum;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_MAX</span></span><br><span class="line">        node.max = max(tree[index * <span class="number">2</span>].max, tree[index * <span class="number">2</span> + <span class="number">1</span>].max);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_MIN</span></span><br><span class="line">        tree[index].min = min(tree[index * <span class="number">2</span>].min, tree[index * <span class="number">2</span> + <span class="number">1</span>].min);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        node.left = left;</span><br><span class="line">        node.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_SUM</span></span><br><span class="line">    <span class="comment">// 求区间和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">querySum</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> index = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= tree[index].left &amp;&amp; right &gt;= tree[index].right) &#123;</span><br><span class="line">            <span class="comment">// 子集</span></span><br><span class="line">            <span class="keyword">return</span> tree[index].sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (tree[index].left + tree[index].right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= mid) &#123;</span><br><span class="line">            <span class="comment">// [left,mid]与询问区间有交集，递归查询左儿子</span></span><br><span class="line">            ans += querySum(left, right, index * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; mid) &#123;</span><br><span class="line">            <span class="comment">// [mid+1,right]与询问区间有交集，递归查询左儿子</span></span><br><span class="line">            ans += querySum(left, right, index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_MAX</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求区间最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">queryMax</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> index = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= tree[index].left &amp;&amp; right &gt;= tree[index].right) &#123;</span><br><span class="line">            <span class="comment">// 子集</span></span><br><span class="line">            <span class="keyword">return</span> tree[index].max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftAns = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> rightAns = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> mid = (tree[index].left + tree[index].right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= mid) &#123;</span><br><span class="line">            leftAns = queryMax(left, right, index * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; mid) &#123;</span><br><span class="line">            rightAns += queryMax(left, right, index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(leftAns, rightAns);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_MIN</span></span><br><span class="line">    <span class="comment">// 求区间最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">queryMin</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> index = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= tree[index].left &amp;&amp; right &gt;= tree[index].right) &#123;</span><br><span class="line">            <span class="comment">// 子集</span></span><br><span class="line">            <span class="keyword">return</span> tree[index].min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftAns = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> rightAns = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> mid = (tree[index].left + tree[index].right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= mid) &#123;</span><br><span class="line">            leftAns = queryMin(left, right, index * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; mid) &#123;</span><br><span class="line">            rightAns = queryMin(left, right, index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(leftAns, rightAns);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_SUM</span></span><br><span class="line">    <span class="comment">// 更新父节点的区间和</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateFatherSum</span><span class="params">(<span class="keyword">int</span> treeIndex)</span> </span>&#123;</span><br><span class="line">        tree[treeIndex].sum = tree[treeIndex * <span class="number">2</span>].sum + tree[treeIndex * <span class="number">2</span> + <span class="number">1</span>].sum;</span><br><span class="line">        <span class="keyword">if</span> (treeIndex != <span class="number">1</span>) &#123;</span><br><span class="line">            updateFatherSum(treeIndex / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_MAX</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateFatherMax</span><span class="params">(<span class="keyword">int</span> treeIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;node = tree[treeIndex];</span><br><span class="line">        <span class="keyword">auto</span> newMax = max(tree[treeIndex * <span class="number">2</span>].max, tree[treeIndex * <span class="number">2</span> + <span class="number">1</span>].max);</span><br><span class="line">        <span class="keyword">if</span> (newMax != node.max &amp;&amp; treeIndex != <span class="number">1</span>) &#123;</span><br><span class="line">            node.max = newMax;</span><br><span class="line">            updateFatherMax(treeIndex / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单点更新</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">long</span> <span class="keyword">long</span> value, <span class="keyword">int</span> treeIndex = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> node = &amp;tree[treeIndex];</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == node-&gt;right) &#123;</span><br><span class="line">            <span class="comment">//当前节点，更新</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_SUM</span></span><br><span class="line">            tree[treeIndex].sum = value;</span><br><span class="line">            updateFatherSum(treeIndex);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_MAX</span></span><br><span class="line">            node-&gt;max = value;</span><br><span class="line">            updateFatherMax(treeIndex / <span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_MIN</span></span><br><span class="line">            tree[treeIndex].min = value;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_MAX</span></span><br><span class="line">        <span class="comment">// 逐渐变小，应该不需要</span></span><br><span class="line">        <span class="comment">// node-&gt;max = max(node-&gt;max, value);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TREE_MIN</span></span><br><span class="line">        tree[treeIndex].min = min(tree[treeIndex].min, value);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">int</span> mid = (node-&gt;left + node-&gt;right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= mid) &#123;</span><br><span class="line">            update(index, value, treeIndex * <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update(index, value, treeIndex * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询第一个大于等于k的元素，通过max&gt;=k确定</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAns</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">long</span> <span class="keyword">long</span> k, <span class="keyword">int</span> treeIndex = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;node = tree[treeIndex];</span><br><span class="line">        <span class="keyword">if</span> (node.max &lt; k) &#123;</span><br><span class="line">            <span class="comment">// 别找了，就没有</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left == node.right) &#123;</span><br><span class="line">            <span class="comment">// 叶子，返回索引</span></span><br><span class="line">            a[node.left] -= k;</span><br><span class="line">            node.max -= k;</span><br><span class="line">            updateFatherMax(treeIndex / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftAns = <span class="number">-1</span>, rightAns = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left &gt;= left &amp;&amp; node.right &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 此节点被包含在区间中</span></span><br><span class="line">            <span class="comment">// 先找左边，是否有大于等于k的</span></span><br><span class="line">            leftAns = getAns(left, right, k, treeIndex * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (leftAns != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> leftAns;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> getAns(left, right, k, treeIndex * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有交集</span></span><br><span class="line">        <span class="keyword">int</span> mid = (node.left + node.right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= mid) &#123;</span><br><span class="line">            leftAns = getAns(left, right, k, treeIndex * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (leftAns != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> leftAns;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> getAns(left, right, k, treeIndex * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> st = SegmentTree(MAX);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t, n, m;</span><br><span class="line">    <span class="keyword">int</span> l, r, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// build tree</span></span><br><span class="line">        st.build(<span class="number">1</span>, n, <span class="number">1</span>, a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">            idx = st.getAns(l, r, k);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; idx &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试例生成（Python）"><a href="#测试例生成（Python）" class="headerlink" title="测试例生成（Python）"></a>测试例生成（Python）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">v</span>(<span class="params">t, n, m, <span class="built_in">max</span>=<span class="number">1e9</span>, filename=<span class="string">&#x27;in&#x27;</span></span>):</span></span><br><span class="line">    t = <span class="built_in">int</span>(t)</span><br><span class="line">    n = <span class="built_in">int</span>(n)</span><br><span class="line">    m = <span class="built_in">int</span>(m)</span><br><span class="line">    <span class="built_in">max</span> = <span class="built_in">int</span>(<span class="built_in">max</span>)</span><br><span class="line">    step = t // <span class="number">10</span></span><br><span class="line">    f = <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&quot;&#123;&#125;\r\n&quot;</span>.<span class="built_in">format</span>(t))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(t):</span><br><span class="line">        a = [<span class="built_in">str</span>(random.randint(<span class="number">1</span>, <span class="built_in">max</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        q = [<span class="string">&quot; &quot;</span>.join([</span><br><span class="line">            <span class="built_in">str</span>(random.randint(<span class="number">1</span>, n // <span class="number">2</span>)),</span><br><span class="line">            <span class="built_in">str</span>(random.randint(n // <span class="number">2</span>, n)),</span><br><span class="line">            <span class="built_in">str</span>(random.randint(<span class="number">1</span>, <span class="built_in">max</span>))]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        f.write(<span class="string">&quot;&#123;&#125; &#123;&#125;\r\n&#123;&#125;\r\n&#123;&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            n, m, <span class="string">&quot; &quot;</span>.join(a), <span class="string">&quot;\r\n&quot;</span>.join(q)</span><br><span class="line">        ))</span><br><span class="line">        <span class="keyword">if</span> i % step == <span class="number">0</span>:</span><br><span class="line">            print(i)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="暴力验证"><a href="#暴力验证" class="headerlink" title="暴力验证"></a>暴力验证</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">&quot;O3&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAX = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t, n, m;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">            <span class="comment">// 暴力</span></span><br><span class="line">            <span class="keyword">for</span> (; l &lt;= r; l++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[l] &gt;= k) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                a[l] -= k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2382</title>
    <url>/2020/06/19/UESTC-2382/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入$n$条有向边，确定是否能一笔画，如果能则输出最大的“起点*终点“，否则输出$-1$。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>欧拉图模板题。</p>
<span id="more"></span>

<p>根据维基百科上的说法，一个连通的有向图有从$u$到$v$欧拉路径的充要条件是$u$的出度比入度多1，$v$的入度比出度多1，其他节点出度等于入度，一个连通的有向图有欧拉回路的充要条件是所有节点的出度等于入度。</p>
<p>所以直接遍历边确定出度和入度就好了。</p>
<p>这题有个坑是给的有向图不一定连通，如果不连通的话当然不会有欧拉路径或欧拉回路。考虑到有向图的单连通+强连通等价于对应无向图的连通，无向图判断连通性的方法有很多，DFS、BFS等等，但是我觉得搜索太麻烦，就用的并查集。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(&quot;O3&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPLAY_A 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edges</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> u, v, ans;</span><br><span class="line"></span><br><span class="line">    Edges(<span class="keyword">int</span> u, <span class="keyword">int</span> v) : u(u), v(v), ans(u * v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Edges &amp;e) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans &lt; e.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集判断连通性</span></span><br><span class="line"><span class="keyword">int</span> dset[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> iSet[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dset[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    dset[x] = find(dset[x]);</span><br><span class="line">    <span class="keyword">return</span> dset[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> pot[<span class="number">101</span>];</span><br><span class="line">    <span class="built_in">memset</span>(pot, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">101</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edges&gt; ct;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="comment">// u -&gt; v</span></span><br><span class="line">        pot[u] -= <span class="number">1</span>;</span><br><span class="line">        pot[v] += <span class="number">1</span>;</span><br><span class="line">        ct.emplace_back(u, v);</span><br><span class="line">        <span class="comment">// 建立并查集，应该能保证不会有环</span></span><br><span class="line">        <span class="keyword">if</span> (dset[u]) &#123;</span><br><span class="line">            <span class="comment">// u在一个集合了</span></span><br><span class="line">            <span class="keyword">if</span> (dset[v]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (find(u) != find(v)) &#123;</span><br><span class="line">                    <span class="comment">// 连接</span></span><br><span class="line">                    dset[find(v)] = find(u);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 已经连通，不管</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dset[v] = find(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dset[v]) &#123;</span><br><span class="line">            <span class="comment">// dset[u] is 0</span></span><br><span class="line">            dset[u] = find(v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 都没有，先建立吧</span></span><br><span class="line">            dset[u] = u;</span><br><span class="line">            dset[v] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> numSet = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dset[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root = find(i);</span><br><span class="line">        <span class="keyword">if</span> (!iSet[root]) &#123;</span><br><span class="line">            iSet[root] = <span class="number">1</span>;</span><br><span class="line">            numSet += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (numSet &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pot[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!end) &#123;</span><br><span class="line">                end = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// unavailable</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pot[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pot[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start &amp;&amp; end) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; start * end &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start == <span class="number">0</span> &amp;&amp; end == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// start和end都为0，找最大的</span></span><br><span class="line">        <span class="keyword">int</span> maxAns = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i:ct) &#123;</span><br><span class="line">            maxAns = max(maxAns, max(i.u, i.v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; maxAns * maxAns &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 只有start或者只有end</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>图论</category>
        <category>欧拉图</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>欧拉图</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2398</title>
    <url>/2020/05/23/UESTC-2398/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定$m$个牛头人和$p$个老哥，老哥向一个方向移动，遇到牛头人时牛头人停止活动，现在给出牛头人出现的时间距离，让所有牛头人加起来的活动时间最短，安排老哥的出发时间。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>参照出题人PPT的状态转移方程。</p>
<p>首先简化问题，假设所有牛头人都出现在起始位置，直接用时间减去距离即可，为了方便后面的操作再排序一下，设为$a[]$，$dp[i][j]$表示第$i$个老哥在$a[j]$时刻出发前$j$牛头人的最少活动时间，于是有状态转移方程<br>$$<br>dp[i][j]=\min{dp[i-1][k]+\sum_{x=k+1}^{j}(a[j]-a[x])|k\in[1,j]}<br>$$<br>考虑用前缀和，令<br>$$<br>s[j]=\sum_{x=1}^ja[x]<br>$$<br>方程可以变为<br>$$<br>dp[i][j]=\min{(dp[i-1][k]+s[k])-k\cdot a[j]+(j\cdot a[j]-s[j])|k\in[1,j]}<br>$$<br>考虑$i\in[1,p]$，$j\in[1,m]$，直接DP的话复杂度依然高达$O(pm^2)$，因为式子中有一项同时包含$k$和$j$，所以无法用单调队列优化，我们考虑斜率优化。</p>
<p>设$k_1&lt;k_2$且$k_2$比$k_1$更优，即<br>$$<br>(dp[i-1][k_2]+s[k_2])-k_2\cdot a[j]+(j\cdot a[j]-s[j])&lt;<br>(dp[i-1][k_1]+s[k_1])-k_1\cdot a[j]+(j\cdot a[j]-s[j])<br>$$</p>
<p>$$<br>(dp[i-1][k_2]+s[k_2])-k_2\cdot a[j]&lt;<br>(dp[i-1][k_1]+s[k_1])-k_1\cdot a[j]<br>$$</p>
<p>$$<br>\frac{(dp[i-1][k_2]+s[k_2])-(dp[i-1][k_1]+s[k_1])}{k_2-k_1}&lt;a[j]<br>$$</p>
<p><del>（虽然我不知道变换出这个式子之后有什么用，总之就放这吧）</del></p>
<p>其实对于斜率优化，我的理解是对于不同的自变量（这里是$k$），取到的值不同，而当$k_1&lt;k_2$且从$k_1$到$k_2$的斜率小于这里的$a[j]$（注意$a[j]$单调不减）时，则后续的状态转移一定不会有$k_1$，因为$k_2$一定比$k_1$更优，同时能取到的点集会有斜率单调不减的特征，也就是一个下凸包，同时那个最优的点就是凸包上第一个斜率大于等于$a[j]$的点，由于$a[j]$单调不减，所以在取了这点之后可以直接将这个点以前的点全部移除。</p>
<p>之后就是代码实现了，我用一个数组来维护下凸包，准确说是一个双向队列（两个变量<code>head</code>和<code>tail</code>，但是STL的<code>deque</code>效率不得行，所以是手写的。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><p>这题<code>int</code>会溢出，我吐了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(&quot;O3&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPLAY_A 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAX];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">100</span> + <span class="number">7</span>][MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">grad</span><span class="params">(<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> *arr, <span class="keyword">long</span> <span class="keyword">long</span> x1, <span class="keyword">long</span> <span class="keyword">long</span> x2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">float</span>) (arr[x2] + sum[x2] - arr[x1] - sum[x1])) / ((<span class="keyword">float</span>) (x2 - x1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ndeq[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> m, p;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp &gt;&gt; a[i];</span><br><span class="line">        a[i] -= tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + m + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>][j] = a[j] * j - sum[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= p; i++) &#123;</span><br><span class="line">        <span class="comment">// 斜率优化</span></span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 必然吧</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        ndeq[tail] = <span class="number">0</span>;</span><br><span class="line">        tail++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="comment">// 准备插入j，维护斜率递增，左侧斜率小于右侧斜率</span></span><br><span class="line">            <span class="keyword">while</span> (tail - head &gt;= <span class="number">2</span> &amp;&amp;</span><br><span class="line">                   grad(dp[i - <span class="number">1</span>], ndeq[tail - <span class="number">2</span>], ndeq[tail - <span class="number">1</span>]) &gt;=</span><br><span class="line">                   grad(dp[i - <span class="number">1</span>], ndeq[tail - <span class="number">1</span>], j)) &#123;</span><br><span class="line">                <span class="comment">// 出栈</span></span><br><span class="line">                tail--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这一点应该是一定会加入的</span></span><br><span class="line">            ndeq[tail] = j;</span><br><span class="line">            tail++;</span><br><span class="line">            <span class="comment">// 找不到情况队处理</span></span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 二分查找</span></span><br><span class="line">            <span class="comment">// 大概直接查找就完事了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = head; k &lt; tail - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                <span class="comment">// 斜率递增，故左斜率&lt;=a[j]&amp;&amp;右斜率&gt;=a[j]时最优</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][ndeq[k + <span class="number">1</span>]] + sum[ndeq[k + <span class="number">1</span>]] - dp[i - <span class="number">1</span>][ndeq[k]] - sum[ndeq[k]] &gt;=</span><br><span class="line">                    a[j] * (ndeq[k + <span class="number">1</span>] - ndeq[k]) &amp;&amp;</span><br><span class="line">                    dp[i - <span class="number">1</span>][ndeq[k]] + a[j] * (j - ndeq[k]) - (sum[j] - sum[ndeq[k]]) &lt;= dp[i][j]) &#123;</span><br><span class="line">                    <span class="comment">// 是这点了</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][ndeq[k]] + a[j] * (j - ndeq[k]) - (sum[j] - sum[ndeq[k]]);</span><br><span class="line">                    <span class="comment">// 修改队首</span></span><br><span class="line">                    head = k;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            head = min(head, tail - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[p][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试例生成（Python）"><a href="#测试例生成（Python）" class="headerlink" title="测试例生成（Python）"></a>测试例生成（Python）</h3><p>为了方便直接将位置都设为0了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">e</span>(<span class="params">m, p, <span class="built_in">max</span>=<span class="number">1e9</span>, filename=<span class="string">&#x27;in&#x27;</span></span>):</span></span><br><span class="line">    m = <span class="built_in">int</span>(m)</span><br><span class="line">    p = <span class="built_in">int</span>(p)</span><br><span class="line">    fi = <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    fi.write(<span class="string">&quot;&#123;&#125; &#123;&#125;\r\n&#123;&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        m, p, <span class="string">&quot;\r\n&quot;</span>.join([</span><br><span class="line">            <span class="string">&quot;0 &#123;&#125;&quot;</span>.<span class="built_in">format</span>(random.randint(<span class="number">0</span>, <span class="built_in">max</span>))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)</span><br><span class="line">        ])</span><br><span class="line">    ))</span><br><span class="line">    fi.close()</span><br></pre></td></tr></table></figure>

<h3 id="暴力验证"><a href="#暴力验证" class="headerlink" title="暴力验证"></a>暴力验证</h3><p>只是没有斜率优化，其他一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(&quot;O3&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPLAY_A 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAX];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">100</span> + <span class="number">7</span>][MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> m, p;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp &gt;&gt; a[i];</span><br><span class="line">        a[i] -= tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + m + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>][j] = a[j] * j - sum[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= p; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][<span class="number">1</span>] + a[j] * (j - <span class="number">1</span>) - (sum[j] - sum[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= j; k++) &#123;</span><br><span class="line">                dp[i][j] = min(dp[i][j], dp[i - <span class="number">1</span>][k] + a[j] * (j - k) - (sum[j] - sum[k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[p][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>动态规划</category>
        <category>斜率优化</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>动态规划</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2402</title>
    <url>/2020/05/08/UESTC-2402/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>这次在每一轮游戏中，綾波需要使用鱼雷把一个区间[l,r]内的所有点的数值变为c，每改变一个点的数值需要消耗一枚特制鱼雷。</p>
<p>尽管如此，在知道了墙面上各点初始数值和每轮的任务后，綾波还是希望指挥官能帮她计算她各轮需要的鱼雷数量的说。呐，快来帮帮綾波吧。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>参照出题人题解PPT。</p>
<p>出题人告诉我们这题可以分块也可以用珂朵莉树。</p>
<p>分块实在太恶心了，所以我就试了下所谓的珂朵莉树，没有去看OI-WiKi，凭着感觉写的，没有用std::set而是用的std::map，当然他们内部也差不多，只是std::map可以很容易地带上一个载荷。</p>
<p>首先是初始化，把所有连续的部分都装进去。</p>
<p>对于每次查询，用二分查找到对对应的块，整块的就直接加到<code>ans</code>，其他的部分单独处理。</p>
<p>因为第一次写这种结构，还出了不少bug。</p>
<p>第一次查询和修改的复杂度都是$O(n)$，之后每次查询和修改的理想复杂度都是$O(\log_2n)$，因为总共$m$次查询，所以总的复杂度大概是$O(m\log_2n)$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>有个宏定义<code>DISPLAY_A</code>用于在每次查询后打印完整的数组。</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(&quot;O3&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPLAY_A 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> left, <span class="keyword">int</span> val, <span class="keyword">int</span> right) : left(left), val(val), right(right) &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> left, <span class="keyword">int</span> val) : left(left), val(val), right(left) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> left) : left(left), val(<span class="number">0</span>), right(left) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node() : left(<span class="number">0</span>), val(<span class="number">0</span>), right(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Node node) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;left &lt; node.left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">100000</span> + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> l, r, c;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, Node&gt; tree;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> right = i;</span><br><span class="line">        <span class="keyword">int</span> i2 = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i2 &lt;= n; i2++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i2] != arr[i2 - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[i] = Node(i, arr[i], right);</span><br><span class="line">        i = i2 - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        <span class="keyword">auto</span> it = tree.lower_bound(l);</span><br><span class="line">        <span class="keyword">auto</span> st = it;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;first != l) &#123;</span><br><span class="line">            st--;</span><br><span class="line">            <span class="comment">// 前面的区域</span></span><br><span class="line">            <span class="keyword">if</span> (st-&gt;second.val != c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (st-&gt;second.right &gt; r) &#123;</span><br><span class="line">                    ans += r - l + <span class="number">1</span>;</span><br><span class="line">                    tree[r + <span class="number">1</span>] = Node(r + <span class="number">1</span>, st-&gt;second.val, st-&gt;second.right);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans += st-&gt;second.right - l + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                st-&gt;second.right = l - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = st-&gt;first;</span><br><span class="line">                <span class="keyword">if</span> (r &lt; st-&gt;second.right) &#123;</span><br><span class="line">                    r = st-&gt;second.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 覆盖的部分</span></span><br><span class="line">        <span class="keyword">for</span> (; it-&gt;second.right &lt;= r &amp;&amp; it != tree.end();) &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;node = it-&gt;second;</span><br><span class="line">            <span class="keyword">if</span> (node.val != c) &#123;</span><br><span class="line">                ans += node.right - node.left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            it++;</span><br><span class="line">            tree.erase(prev(it));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后面的区域</span></span><br><span class="line">        <span class="keyword">auto</span> et = it;</span><br><span class="line">        <span class="keyword">if</span> (et-&gt;first &lt;= r &amp;&amp; et != tree.end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (et-&gt;second.val != c) &#123;</span><br><span class="line">                ans += r - et-&gt;first + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (et-&gt;second.right - et-&gt;first &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 长度大于1的时候才行，不然会错位</span></span><br><span class="line">                    tree[r + <span class="number">1</span>] = Node(r + <span class="number">1</span>, et-&gt;second.val, et-&gt;second.right);</span><br><span class="line">                &#125;</span><br><span class="line">                tree.erase(et);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = et-&gt;second.right;</span><br><span class="line">                tree.erase(et);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[l] = Node(l, c, r);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPLAY_A</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> itt:tree) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = itt.second.left; i &lt;= itt.second.right; i++) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; itt.second.val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试例生成（Python）"><a href="#测试例生成（Python）" class="headerlink" title="测试例生成（Python）"></a>测试例生成（Python）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">z</span>(<span class="params">n, m, <span class="built_in">max</span>=<span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>, filename=<span class="string">&#x27;in&#x27;</span></span>):</span></span><br><span class="line">    n = <span class="built_in">int</span>(n)</span><br><span class="line">    m = <span class="built_in">int</span>(m)</span><br><span class="line">    fi = <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    fi.write(<span class="string">&quot;&#123;&#125;\r\n&#123;&#125;\r\n&#123;&#125;\r\n&#123;&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        n, <span class="string">&quot; &quot;</span>.join([<span class="built_in">str</span>(random.randint(-<span class="built_in">max</span>, <span class="built_in">max</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]),</span><br><span class="line">        m,</span><br><span class="line">        <span class="string">&quot;\r\n&quot;</span>.join([</span><br><span class="line">            <span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                random.randint(<span class="number">1</span>, n // <span class="number">2</span>),</span><br><span class="line">                random.randint(n // <span class="number">2</span>, n),</span><br><span class="line">                random.randint(-<span class="built_in">max</span>, <span class="built_in">max</span>),</span><br><span class="line">            ) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)</span><br><span class="line">        ])</span><br><span class="line">    ))</span><br><span class="line">    fi.close()</span><br></pre></td></tr></table></figure>

<h3 id="暴力验证"><a href="#暴力验证" class="headerlink" title="暴力验证"></a>暴力验证</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">&quot;O3&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPLAY_A 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">100000</span> + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> l, r, c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != arr[i]) &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                arr[i] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPLAY_A</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>数据结构</category>
        <category>珂朵莉树</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>数据结构</tag>
        <tag>珂朵莉树</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2404</title>
    <url>/2020/05/23/UESTC-2404/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给一颗$n$节点的树，1节点为根节点，求最少减去多少条边可以得到一颗$p$节点的树。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>参照<a href="https://www.luogu.com.cn/problem/P1272">洛谷P1272</a>。</p>
<p>基本上是原题了。</p>
<p>$dp[i][j]$表示以$i$为根节点时获得节点数为$p$的树最少需要的修建次数。状态转移方程<br>$$<br>dp[i][j]=\min{dp[i][j-k]+dp[son][k]-1|k\in[1,j]}<br>$$<br>$son$是$i$的子节点。</p>
<p>考虑到不一定1为根节点（$dp[1][p]$）才是最优，所以我们可以遍历每一个节点作为根节点的情况。注意到除了根节点之外，其他节点为根节点的话需要断开自己与父节点的边，所以遍历的时候+1即可。</p>
<p>还有一个坑是输入。每行输入的是$u$和$v$表示$u$和$v$之间有一条边，然而并不知道哪个是父节点，所以得专门做一次处理，我懒得搞骚操作直接暴力了，速度还行吧。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(&quot;O3&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPLAY_A 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">200</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; nodes[<span class="number">201</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> son:nodes[root]) &#123;</span><br><span class="line">        sum += dfs(son);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> optimize</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = sum; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                dp[root][j] = min(dp[root][j], dp[root][j - k] + dp[son][k] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dset[<span class="number">201</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, p;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    dset[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[i][j] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建单向边</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, Edge&gt; edge;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="comment">// 干就完事了</span></span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">1</span>) &#123;</span><br><span class="line">            nodes[u].insert(v);</span><br><span class="line">            dset[v] = u;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v == <span class="number">1</span>) &#123;</span><br><span class="line">            nodes[v].insert(u);</span><br><span class="line">            dset[u] = v;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dset[u]) &#123;</span><br><span class="line">            nodes[u].insert(v);</span><br><span class="line">            dset[v] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dset[v]) &#123;</span><br><span class="line">            nodes[v].insert(u);</span><br><span class="line">            dset[u] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 姑且记录一下</span></span><br><span class="line">            edge[cnt].u = u;</span><br><span class="line">            edge[cnt].v = v;</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; af;</span><br><span class="line">    <span class="keyword">while</span> (!edge.empty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it:edge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dset[it.second.u]) &#123;</span><br><span class="line">                nodes[it.second.u].insert(it.second.v);</span><br><span class="line">                dset[it.second.v] = <span class="number">1</span>;</span><br><span class="line">                af.insert(it.first);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dset[it.second.v]) &#123;</span><br><span class="line">                nodes[it.second.v].insert(it.second.u);</span><br><span class="line">                dset[it.second.u] = <span class="number">1</span>;</span><br><span class="line">                af.insert(it.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it:af) &#123;</span><br><span class="line">            edge.erase(it);</span><br><span class="line">        &#125;</span><br><span class="line">        af.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = nodes[i].size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// search</span></span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = dp[<span class="number">1</span>][p];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPLAY_A</span></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPLAY_A</span></span><br><span class="line">        <span class="keyword">if</span> (ans &gt; dp[i][p] + <span class="number">1</span>) &#123;</span><br><span class="line">            ans = dp[i][p] + <span class="number">1</span>;</span><br><span class="line">            idx = i;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        ans = min(ans, dp[i][p] + <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPLAY_A</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; idx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试例生成（Python）"><a href="#测试例生成（Python）" class="headerlink" title="测试例生成（Python）"></a>测试例生成（Python）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">N</span>(<span class="params">n, p, filename=<span class="string">&#x27;in&#x27;</span></span>):</span></span><br><span class="line">    n = <span class="built_in">int</span>(n)</span><br><span class="line">    p = <span class="built_in">int</span>(p)</span><br><span class="line">    f = <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&quot;&#123;&#125; &#123;&#125;\r\n&#123;&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        n, p,</span><br><span class="line">        <span class="string">&quot;\r\n&quot;</span>.join([</span><br><span class="line">            <span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(random.randint(<span class="number">1</span>, i - <span class="number">1</span>), i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>)</span><br><span class="line">        ])</span><br><span class="line">    ))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>动态规划</category>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>动态规划</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2427</title>
    <url>/2020/05/23/UESTC-2427/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给一组长度为$n$序列，相邻的数字可以合并为一个数字，合并后的数字等于合并前的数字+1，问合并后的数字最少是多少个。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>参照出题人PPT，是区间DP没错了。</p>
<p>$dp[l][r]$表示区间$[l,r]$在合并过之后有多少个数，$ag[l][r]$表示区间$[l,r]$合并成一个（如果可以）的数。</p>
<p>不好解释，直接看代码吧。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = l; mid &lt;= r; mid++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (dp[l][mid] == <span class="number">1</span> &amp;&amp; dp[mid + <span class="number">1</span>][r] == <span class="number">1</span> &amp;&amp;</span><br><span class="line">      ag[l][mid] == ag[mid + <span class="number">1</span>][r] &amp;&amp; ag[l][mid] != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// merge</span></span><br><span class="line">    dp[l][r] = <span class="number">1</span>;</span><br><span class="line">    ag[l][r] = ag[l][mid] + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dp[l][r] = min(dp[l][r], dp[l][mid] + dp[mid + <span class="number">1</span>][r]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于区间$[l,r]$，将其分为$[l,mid]$和$[mid+1,r]$，看能否合并，然后最小值。</p>
<p>然后枚举长度和$l$即可，复杂度$O(n^3)$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>因为一发入魂，就没写测试例生成和暴力程序了。</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(&quot;O3&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPLAY_A 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">500</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[MAX];</span><br><span class="line"><span class="keyword">int</span> ag[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> dp[MAX][MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[i][j] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        ag[i][i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; len++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + len &lt;= n; l++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = l + len;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mid = l; mid &lt;= r; mid++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[l][mid] == <span class="number">1</span> &amp;&amp; dp[mid + <span class="number">1</span>][r] == <span class="number">1</span> &amp;&amp;</span><br><span class="line">                    ag[l][mid] == ag[mid + <span class="number">1</span>][r] &amp;&amp; ag[l][mid] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// merge</span></span><br><span class="line">                    dp[l][r] = <span class="number">1</span>;</span><br><span class="line">                    ag[l][r] = ag[l][mid] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[l][r] = min(dp[l][r], dp[l][mid] + dp[mid + <span class="number">1</span>][r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>动态规划</category>
        <category>区间DP</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>动态规划</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2428</title>
    <url>/2020/05/23/UESTC-2428/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给一段长度为$n$的序列，包含$1\sim m$的数字，可以任意交换两个数字的位置，目标是让所有相同的数字相邻，问最多可以有几个数字的位置不被交换。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>参照出题人的PPT。</p>
<p>把“已经排列好的数字种类的集合”视为状态，不考虑集合中数字的顺序，他们的总数是固定的，记状态为$s$，已经排列的人数为$f[s]$，这个可以在输入的时候直接求出来。$m$最大只有20，直接位运算来实现集合。$dp[s]$表示状态$s$最多能固定的数字数量。</p>
<p>枚举$s$，在每次枚举的时候枚举数字$i$，考虑</p>
<ul>
<li>$i$不在$s$中，则$dp[s|(1&lt;&lt;i)]=\max{dp[s]+sum[r][i]-sum[l-1][i]|i\in[0,m-1]}$</li>
<li>$i$在$s$中，则$dp[s]=\max{dp[s\oplus(1&lt;&lt;i)]+sum[r][i]-sum[l-1][i]|i\in[0,m-1]}$</li>
</ul>
<p>注意我为了方便位运算将输入序列全部减去1。</p>
<p>最后输出$dp[(1&lt;&lt;m)-1]$即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>因为一发入魂，所以没有写测试例生成和暴力验证。</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(&quot;O3&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPLAY_A 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span> &lt;&lt; <span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1</span> &lt;&lt; <span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> a[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> sum[MAX + <span class="number">1</span>][<span class="number">20</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; c; c &gt;&gt;= <span class="number">1</span>, k++) &#123;</span><br><span class="line">        ans += c &amp; <span class="number">1</span> ? sum[n][k] : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        <span class="comment">// 从0开始</span></span><br><span class="line">        a[i] -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            sum[i][j] = sum[i - <span class="number">1</span>][j] + (j == a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> full = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= full; i++) &#123;</span><br><span class="line">        f[i] = getSum(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (s &lt;= full) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = f[s] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = f[s | (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">            <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                dp[s] = max(dp[s], dp[s - (<span class="number">1</span> &lt;&lt; i)] + sum[r][i] - sum[l - <span class="number">1</span>][i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[s | (<span class="number">1</span> &lt;&lt; i)] = max(dp[s | (<span class="number">1</span> &lt;&lt; i)], dp[s] + sum[r][i] - sum[l - <span class="number">1</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[full] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>动态规划</category>
        <category>状压DP</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>动态规划</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2429</title>
    <url>/2020/05/23/UESTC-2429/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>和<a href="https://blog.ch34k.xyz/2020/05/23/UESTC-2428/">UESTC-2428</a>基本相同，区别在于只能相邻的两个进行交换，询问最少交换次数。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>有一说一，这题我没怎么搞懂，基本上全靠出题人的PPT。</p>
<p>这题比较直白了，直接就是$1\sim 20$的数字。继续使用状态压缩，变量$s$二进制表示状态，$dp[s]$表示状态$s$需要的最少交换次数，$w[i][j]$表示原排列i在j前面的对数，状态转移方程<br>$$<br>dp[s]=\min{dp[s-(1&lt;&lt;i)]+\sum_{j\in s &amp;j\ne i}w[i][j]}<br>$$<br>显然$dp[0]=0$。</p>
<p>$w$直接暴力就行，题解上给的做法也是暴力。（学姐真是太良心了）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>虽然没有一发入魂（某个循环的边界写错了），但是调了几下就过了，所以也没有写测试例生成和暴力验证……</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(&quot;O3&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPLAY_A 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAX];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">27</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">27</span>][<span class="number">27</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> full = (<span class="number">1u</span> &lt;&lt; <span class="number">20u</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[full + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        a[i] -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cnt[a[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">            w[j][a[i]] += cnt[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; s &lt;= full; s++) &#123;</span><br><span class="line">        dp[s] = <span class="number">0x7fffffffffffffff</span>ll;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(s &amp; (<span class="number">1</span> &lt;&lt; i))) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j || !(s &amp; (<span class="number">1</span> &lt;&lt; j))) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += w[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[s] = min(dp[s], dp[s - (<span class="number">1</span> &lt;&lt; i)] + ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[full] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>动态规划</category>
        <category>状压DP</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>动态规划</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2430</title>
    <url>/2020/05/23/UESTC-2430/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有$n$种普通物品，第$i$种物品的体积为$V_i$，价值$W_i$，数量$D_i$，有$m$件神奇物品，神奇物品的价值由分配的体积$V_i$决定，计算公式为<br>$$<br>W_i=x_iV_i^2+y_iV_i+z_i<br>$$<br>给一个体积为$C$的背包，求最大价值。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><blockquote>
<p>多重背包+泛化物品。</p>
</blockquote>
<p>先说多重背包的部分。</p>
<p>其实背包问题没啥好讲的，考虑0-1背包，$dp[i][j]$表示前$i$个物品在容量为$j$的背包下的最大价值，有状态转移方程<br>$$<br>dp[i][j]=\max(dp[i-1][j],dp[i-1][j-V_i]+W_i)<br>$$<br>这题数据量比较小，直接朴素做法就行，把多重背包考虑为多个相同重量和价值的物品，就可以转变为0-1背包，时间复杂度$O(nCD)$（讲道理这已经达到1e9了，居然没超时）。</p>
<p>再来说一下泛化物品。</p>
<p>参照背包九讲中关于泛化物品的部分。计算完多重背包的部分之后，我们得到了一个在没有神奇物品情况下，任意容量背包能装的最大价值。背包九讲中对于多个泛化物品的操作是两两合并，这样就只有一个泛化物品了，但是我觉得太麻烦，其实泛化物品就相当于有$C$个一般物品，并且将它们放到一个组（也就是只能拿一个，因为泛化物品只有一个），这样就转变为分组背包，遍历容量然后求最大值就行，同样考虑$dp[i][j]$为前$i$个神奇物品在容量为$j$的背包下的最大价值，转移方程为<br>$$<br>dp[i][j]=\max{dp[i-1][j-v]+x_iv^2+y_iv^2+z_i|v\in[1,j]}<br>$$<br>注意到$j$是两重循环，所以是这部分复杂度是$O(mC^2)$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><del>暴力测试的程序代码找不到了，嘤嘤嘤。</del></p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><p><code>OPTIMIZE</code>是二进制优化，在写这题的时候没有并没有完成这一部分，朴素暴过去的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(&quot;O3&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPLAY_A 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPTIMIZE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> weight, value, number;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Special</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (weight == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> max(<span class="number">0</span>, z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x * weight * weight + y * weight + z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thing things[<span class="number">1007</span> * <span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">Special specials[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp0[<span class="number">1007</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1007</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pow2[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> OPTIMIZE</span></span><br><span class="line"><span class="comment">// 二进制优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">optimize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st = cnt;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (things[cnt].number &gt; pow2[d]) &#123;</span><br><span class="line">        things[cnt].number -= pow2[d];</span><br><span class="line">        things[d + <span class="number">1</span>].number = <span class="number">1</span>;</span><br><span class="line">        things[d + <span class="number">1</span>].weight = things[cnt].weight * pow2[d];</span><br><span class="line">        things[d + <span class="number">1</span>].value = things[cnt].value * pow2[d];</span><br><span class="line">        d += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    things[cnt].weight = things[cnt].weight * things[cnt].number;</span><br><span class="line">    things[cnt].value = things[cnt].value * things[cnt].number;</span><br><span class="line">    things[cnt].number = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 考虑不拿的情况</span></span><br><span class="line">    cnt += d + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPLAY_A</span></span><br><span class="line"><span class="keyword">int</span> sp[<span class="number">1007</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m, c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; things[cnt].weight &gt;&gt; things[cnt].value &gt;&gt; things[cnt].number;</span><br><span class="line">        <span class="comment">// 多重背包</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OPTIMIZE</span></span><br><span class="line">        <span class="comment">// 二进制优化</span></span><br><span class="line">        <span class="keyword">auto</span> st = optimize();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = st; k &lt; cnt; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; things[k].weight) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j] = max(dp[j], dp0[j - things[k].weight] + things[k].value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(dp0, dp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * c + <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++) &#123;</span><br><span class="line">            <span class="comment">// 不拿的情况(k=0)已经包含了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= things[cnt].number; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> weight = k * things[cnt].weight;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; weight) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j] = max(dp[j], dp0[j - weight] + things[cnt].value * k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(dp0, dp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (c + <span class="number">3</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; specials[i].x &gt;&gt; specials[i].y &gt;&gt; specials[i].z;</span><br><span class="line">        <span class="comment">// 计算神奇物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= c; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; k++) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPLAY_A</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j] &lt; dp0[j - k] + specials[i].getValue(k)) &#123;</span><br><span class="line">                    dp[j] = dp0[j - k] + specials[i].getValue(k);</span><br><span class="line">                    sp[i] = k;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                dp[j] = max(dp[j], dp0[j - k] + specials[i].getValue(k));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(dp0, dp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (c + <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPLAY_A</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sp[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[c] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试例生成（Python）"><a href="#测试例生成（Python）" class="headerlink" title="测试例生成（Python）"></a>测试例生成（Python）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">G</span>(<span class="params">n, m, c, <span class="built_in">max</span>=<span class="number">1e3</span>, filename=<span class="string">&#x27;/Volumes/RD/in&#x27;</span></span>):</span></span><br><span class="line">    n = <span class="built_in">int</span>(n)</span><br><span class="line">    m = <span class="built_in">int</span>(m)</span><br><span class="line">    c = <span class="built_in">int</span>(c)</span><br><span class="line">    f = <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;\r\n&#123;&#125;\r\n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        n, m, c, <span class="string">&quot;\r\n&quot;</span>.join([</span><br><span class="line">            <span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(random.randint(<span class="number">1</span>, <span class="built_in">max</span>), random.randint(<span class="number">1</span>, <span class="built_in">max</span>), random.randint(<span class="number">1</span>, <span class="built_in">max</span>))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)</span><br><span class="line">        ]),</span><br><span class="line">        <span class="string">&quot;\r\n&quot;</span>.join([</span><br><span class="line">            <span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(random.randint(-<span class="built_in">max</span>, <span class="built_in">max</span>), random.randint(-<span class="built_in">max</span>, <span class="built_in">max</span>), random.randint(-<span class="built_in">max</span>, <span class="built_in">max</span>))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)</span><br><span class="line">        ])</span><br><span class="line">    ))</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>动态规划</category>
        <category>背包DP</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>动态规划</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2431</title>
    <url>/2020/05/23/UESTC-2431/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给任意一个字符串，求最少插入多少字符可以得到回文串。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>参照<a href="https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/">leetcode 1312</a>。</p>
<p>求该字符串与它的反序的最长公共子序列（LCS）长度，然后用字符串长度减去这个长度，输出答案完事，时间复杂度为字符串长度的平方。签到题。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>因为一发入魂，就没写测试例生成和暴力验证。</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(&quot;O3&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPLAY_A 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">5e3</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="built_in">string</span> inv = s;</span><br><span class="line">    reverse(inv.begin(), inv.end());</span><br><span class="line">    <span class="comment">// LCS</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] == inv[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n - dp[n][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>动态规划</category>
        <category>LCS</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LCS</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2440</title>
    <url>/2020/05/23/UESTC-2440/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>和<a href="https://blog.ch34k.xyz/2020/05/23/UESTC-2430/">UESTC-2430</a>完全一致，数据量增大。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我觉得没写啥的必要了，和<a href="https://blog.ch34k.xyz/2020/05/23/UESTC-2430/">UESTC-2430</a>完全一致，加上二进制优化就行。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><p>这是debug之后了的，注意到打开了<code>OPTIMIZE</code>宏。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(&quot;O3&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPLAY_A 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPTIMIZE 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> weight, value, number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Special</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getValue</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (weight == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> max(<span class="number">0ll</span>, z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x * weight * weight + y * weight + z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thing things[<span class="number">10007</span> * <span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">Special specials[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp0[<span class="number">10007</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">10007</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pow2[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>, <span class="number">4096</span>, <span class="number">8192</span>, <span class="number">16384</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> OPTIMIZE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二进制优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">optimize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st = cnt;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (things[cnt].number &gt; pow2[d]) &#123;</span><br><span class="line">        things[cnt].number -= pow2[d];</span><br><span class="line">        <span class="comment">// things[d + 1].number = 1;</span></span><br><span class="line">        things[cnt + d + <span class="number">1</span>].weight = things[cnt].weight * pow2[d];</span><br><span class="line">        things[cnt + d + <span class="number">1</span>].value = things[cnt].value * pow2[d];</span><br><span class="line">        d += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    things[cnt].weight = things[cnt].weight * things[cnt].number;</span><br><span class="line">    things[cnt].value = things[cnt].value * things[cnt].number;</span><br><span class="line">    <span class="comment">// things[cnt].number = 1;</span></span><br><span class="line">    cnt += d + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPLAY_A</span></span><br><span class="line"><span class="keyword">int</span> sp[<span class="number">1007</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m, c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; things[cnt].weight &gt;&gt; things[cnt].value &gt;&gt; things[cnt].number;</span><br><span class="line">        <span class="comment">// 多重背包</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OPTIMIZE</span></span><br><span class="line">        <span class="comment">// 二进制优化</span></span><br><span class="line">        optimize();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++) &#123;</span><br><span class="line">            <span class="comment">// 不拿的情况(k=0)已经包含了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= things[cnt].number; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> weight = k * things[cnt].weight;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; weight) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j] = max(dp[j], dp0[j - weight] + things[cnt].value * k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(dp0, dp, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) * (c + <span class="number">3</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; things[i].weight) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j] = max(dp0[j], dp0[j - things[i].weight] + things[i].value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(dp0, dp, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) * (c + <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; specials[i].x &gt;&gt; specials[i].y &gt;&gt; specials[i].z;</span><br><span class="line">        <span class="comment">// 计算神奇物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= c; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; k++) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPLAY_A</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j] &lt; dp0[j - k] + specials[i].getValue(k)) &#123;</span><br><span class="line">                    dp[j] = dp0[j - k] + specials[i].getValue(k);</span><br><span class="line">                    sp[i] = k;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                dp[j] = max(dp[j], dp0[j - k] + specials[i].getValue(k));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(dp0, dp, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) * (c + <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPLAY_A</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sp[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[c] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试例生成（Python）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">G</span>(<span class="params">n, m, c, <span class="built_in">max</span>=<span class="number">1e3</span>, filename=<span class="string">&#x27;/Volumes/RD/in&#x27;</span></span>):</span></span><br><span class="line">    n = <span class="built_in">int</span>(n)</span><br><span class="line">    m = <span class="built_in">int</span>(m)</span><br><span class="line">    c = <span class="built_in">int</span>(c)</span><br><span class="line">    f = <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;\r\n&#123;&#125;\r\n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        n, m, c, <span class="string">&quot;\r\n&quot;</span>.join([</span><br><span class="line">            <span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(random.randint(<span class="number">1</span>, <span class="built_in">max</span>), random.randint(<span class="number">1</span>, <span class="built_in">max</span>), random.randint(<span class="number">1</span>, <span class="built_in">max</span>))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)</span><br><span class="line">        ]),</span><br><span class="line">        <span class="string">&quot;\r\n&quot;</span>.join([</span><br><span class="line">            <span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(random.randint(-<span class="built_in">max</span>, <span class="built_in">max</span>), random.randint(-<span class="built_in">max</span>, <span class="built_in">max</span>), random.randint(-<span class="built_in">max</span>, <span class="built_in">max</span>))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)</span><br><span class="line">        ])</span><br><span class="line">    ))</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>动态规划</category>
        <category>背包DP</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>动态规划</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2459</title>
    <url>/2020/06/20/UESTC-2459/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给两段字符串$A$和$B$，输出$A$中所有出现$B$的位置。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题是老KMP了，不过还是说下怎么做吧<del>不然太水了</del>。</p>
<span id="more"></span>

<p>其实KMP可以看成是一个状态机，按照模式串（也就是要匹配的字符串，这里是$B$）建立状态转移，字符串作为输入。</p>
<p>理论上来说一个状态应该有多个转移方式，由当前状态（也就是匹配到的位置）和下一个字符来决定转移到哪个状态，但是为了方便，我们只取两种，即匹配成功和匹配失败，这样的简化与前面的那个方式基本上是等价的，这也就是<code>next</code>数组的由来，<code>next[i]</code>表示在第<code>i</code>位失配时模式串指针应该回退到的位置，而<code>next</code>数组本身的含义是“字符串的前缀与后缀相同的最大长度”，其中“前缀”指除了最后一个字符以外，一个字符串的全部头部组合，“后缀”指除了第一个字符以外，一个字符串的全部尾部组合。</p>
<p>另外一点，与普通的查找字符串不同的是，这题要求的是所有出现的位置，所以对于一个长度为$n$的模式串，在计算<code>next</code>数组的时候需要计算到第$n$位，也就是说在完全匹配（也就是模式串指针到达尾部）的时候模式串指针应该进行同样的跳转而不是回到0。</p>
<p>说实话对于KMP还是有一点迷糊，虽然知道它的原理，但总是觉得自己并没有真正理解。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(&quot;O3&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPLAY_A 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nextt[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = p.length();</span><br><span class="line">    nextt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; len) &#123;</span><br><span class="line">        <span class="comment">//p[k]表示前缀，p[j]表示后缀（并没有“真”！）</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])<span class="comment">//j在这</span></span><br><span class="line">        &#123;</span><br><span class="line">            j++;<span class="comment">//j+1在这</span></span><br><span class="line">            k++;<span class="comment">//k=k+1</span></span><br><span class="line">            <span class="comment">//----&gt;若p[k]=p[j]，则next[j+1]=next[j]+1;</span></span><br><span class="line">            <span class="comment">//下一个位置的next</span></span><br><span class="line">            <span class="keyword">if</span> (p[j] != p[k])<span class="comment">//当p[k]！=p[j]时，与主串不匹配时可以返回到这</span></span><br><span class="line">            &#123;</span><br><span class="line">                nextt[j] = k;</span><br><span class="line">            &#125; <span class="keyword">else</span><span class="comment">//当p[j]=p[k]时与主串匹配时你在j位置不匹配匹配串返回这里当前</span></span><br><span class="line">                <span class="comment">//还是 不能与主串匹配，然后还是要返回next[]即next[next[k]]</span></span><br><span class="line">                nextt[j] = nextt[k];<span class="comment">//优化了</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = nextt[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    getline(<span class="built_in">cin</span>, a);</span><br><span class="line">    getline(<span class="built_in">cin</span>, b);</span><br><span class="line">    getNext(b);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length();) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || a[i] == b[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = nextt[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == b.length()) &#123;</span><br><span class="line">            <span class="comment">// 匹配成功</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> - j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            j = nextt[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试例生成（Python）"><a href="#测试例生成（Python）" class="headerlink" title="测试例生成（Python）"></a>测试例生成（Python）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>(<span class="params">lenA, lenB, r=<span class="number">50</span>, filename=<span class="string">&#x27;in&#x27;</span></span>):</span></span><br><span class="line">    asciiSet = <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">126</span> + <span class="number">1</span>)</span><br><span class="line">    a = <span class="string">&quot;&quot;</span>.join([<span class="built_in">chr</span>(asciiSet[random.randint(<span class="number">32</span>, <span class="number">32</span> + r) - <span class="number">32</span>]) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(lenA)])</span><br><span class="line">    b = <span class="string">&quot;&quot;</span>.join([<span class="built_in">chr</span>(asciiSet[random.randint(<span class="number">32</span>, <span class="number">32</span> + r) - <span class="number">32</span>]) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(lenB)])</span><br><span class="line">    f = <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    f.write(a)</span><br><span class="line">    f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    f.write(b)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>

<h3 id="暴力验证"><a href="#暴力验证" class="headerlink" title="暴力验证"></a>暴力验证</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @author: hzy</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(&quot;O3&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPLAY_A 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    getline(<span class="built_in">cin</span>, a);</span><br><span class="line">    getline(<span class="built_in">cin</span>, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (<span class="keyword">int</span>)(a.length() - b.length()); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; b.length() &amp;&amp; a[c + i] == b[j]) &#123;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">            c += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == b.length()) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>字符串与搜索</category>
        <category>KMP</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>KMP</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 2503</title>
    <url>/2020/07/08/UESTC-2503/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Alice 和 Bob 在做游戏。有一个长度为$n$的正整数序列，Alice 先手，两人轮流操作。Alice 需要删掉一个非空连续子段，子段和为奇数；Bob 需要删掉一个非空连续子段，子段和为偶数。删除子段后左右两段拼接起来形成新的序列。不能操作的人输。如果两个人都足够聪明，那么谁会获胜？</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>直接判断序列中有没有奇数就行，有的话就是Alice获胜，没有则Bob获胜。</p>
<p>如何推导出这个结论呢？</p>
<p>Alice先手，而Alice只能拿和为奇数的子串，</p>
<ul>
<li><p>如果一开始就全部是偶数，那么就不存在和为奇数的子串，Alice必输。</p>
</li>
<li><p>假如有奇数，我们知道奇数+偶数是奇数，所以对于一个存在奇数的序列，</p>
<ul>
<li>如果序列和就是奇数，那么Alice可以直接拿完，Bob无法继续，Alice获胜。</li>
<li>如果序列和是偶数，那么Alice可以拿到只剩下一个奇数，此时<ul>
<li>剩下0个偶数，Bob无法拿取，Alice获胜。</li>
<li>剩下若干偶数和一个奇数，此时Bob还可以拿一次，下一次Alice可以直接拿完，Bob无法拿取，Alice获胜。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这就是我推导出的全过程。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="AC代码（Python）"><a href="#AC代码（Python）" class="headerlink" title="AC代码（Python）"></a>AC代码（Python）</h3><p>超级简单，只有8行。</p>
<p>因为一发入魂，所以没有写测试例生成和暴力验证。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">input</span>()</span><br><span class="line">arr = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line">        print(<span class="string">&#x27;Alice&#x27;</span>)</span><br><span class="line">        exit()</span><br><span class="line">        </span><br><span class="line">print(<span class="string">&#x27;Bob&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ICPC训练</category>
        <category>数学与几何</category>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>goturn error</title>
    <url>/2019/04/21/goturn-error/</url>
    <content><![CDATA[<h1 id="GOTURN使用二值图报错"><a href="#GOTURN使用二值图报错" class="headerlink" title="GOTURN使用二值图报错"></a>GOTURN使用二值图报错</h1><p>一般在做比较干净的图像的追踪的时候通常会把图像二值化后再处理，对于goturn我也是这么用的，于是就出现了文章标题的情况。这种时候建议直接处理（虽然速度会慢很多），另外关于如何让GOTURN食用二值图的方法我暂时还没发现。</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>ldap-python基本使用</title>
    <url>/2020/04/20/ldap-python%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>因为<a href="https://github.com/MrThanlon/starsso">StarSSO</a>这个项目，我不得不专门补了下LDAP的有关知识和概念，这里记录一下。</p>
<h2 id="LDAP基本概念"><a href="#LDAP基本概念" class="headerlink" title="LDAP基本概念"></a>LDAP基本概念</h2><p>LDAP(Lightweight Directory Access Protocol，轻型目录访问协议)是一个协议，但是我们一般认为它用于存储用户数据，比如手机号、电子邮箱、密码（当然是加密后的）、用户名之类的信息。</p>
<p>和大多数数据库一样，它有服务端和客户端，服务端存储，客户端查询。</p>
<p>从名字我们就知道它是一种目录结构，典型的比如一般文件系统的文件夹就是一种目录，每个目录下可以存放多个条目（<strong>entry</strong>），一般来说一个条目就是一个用户或者组织，条目中可以存放多个属性（<strong>attribute</strong>），这些属性就是上面提到的用户名（一般是<strong>cn</strong>，即common name）、密码（一般是<strong>userPassword</strong>）、电子邮箱、手机号等等。一般一个条目必须拥有的属性是objectClass，用来表示条目的类型，比如<strong>person</strong>或者<strong>orgnizationalUnit</strong>，可以认为不同的objectClass可以拥有不同的属性。</p>
<p>每个条目都有一个唯一的<strong>dn</strong>（distinguished name，专有名称），比如说<code>cn=admin,dc=example,dc=com</code>就是一条dn，它表示在<code>com</code>这个dc下的<code>example</code>这个dc下有个cn为admin的条目，通常LDAP在安装之后的管理员账户就是<code>cn=admin,dc=nodomain</code>。</p>
<p>关于LDAP的更多知识可以在<a href="http://www.ldap.org.cn/">这个网站</a>找到，这里就不展开了。</p>
<h2 id="python-ldap"><a href="#python-ldap" class="headerlink" title="python-ldap"></a>python-ldap</h2><p>如果我们使用的编程语言是Python，可以使用<a href="https://www.python-ldap.org/">python-ldap</a>这个包来访问LDAP，Linux下安装需要编译，可以安装openldap或者openldap-dev（取决于发行版）来获得相应的头文件和链接库。</p>
<p>然而这个包的文档十分简单粗暴，它本身只是对LDAP的C语言接口做了简单封装，所以各种C语言的函数比如add/add_s都完美继承了下来，大量的函数都带有_s/_ext/_ext_s，我也是看了C语言接口的文档才知道_s的意思是同步（Synchronize），也就是说会阻塞知道执行完成，而不带_s的函数是异步执行，返回一个消息，然后通过另一个函数来获得执行的结果。</p>
<p>使用这个包看文档是不够的，更多时候应该关注官方仓库里的Demo和调试器窗口，因为文档里根本不会告诉你返回值是个什么东西。</p>
<p>下面介绍一些常用的操作：</p>
<h3 id="ldap-initialize"><a href="#ldap-initialize" class="headerlink" title="ldap.initialize"></a><a href="https://www.python-ldap.org/en/python-ldap-3.2.0/reference/ldap.html#ldap.initialize">ldap.initialize</a></h3><p>连接LDAP数据库，返回一个LDAPObject，用于后续的各种操作。</p>
]]></content>
      <tags>
        <tag>ldap</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>周小记2018-10-29</title>
    <url>/2018/10/29/%E5%91%A8%E5%B0%8F%E8%AE%B02018-10-29/</url>
    <content><![CDATA[<p>胸口左下侧大概是肋骨的位置有点小痛，如果明天还痛的话就去医院看看。</p>
<p>最近把 <em>记忆大师</em>项目搞定了，也顺便帮卢老爷的抢答器的代码写完了，除了他的蜂鸣器不工作以外<em>（猜测是电压不够）</em>，其他都完成要求了。</p>
<p>前几天接了川师大一个学长的<em>QQ机器人</em>的活，用来转发消息和审核内容什么的，我觉得我们学校的失物招领群也可以这么搞。</p>
<p><em>UESTC-life</em>的后端又双叒叕出问题了，<em>check_token.php</em>这个接口，出现了玄学bug，有空再处理吧。张义飞学长居然开工了，我还以为要等到12月他才会继续的，看来大概是忙完这一小阶段了吧，祝他早日追到妹子。看git记录发现上一次更新居然是10月初，我大概是有一个月没接触这个项目了。看到之前写的代码就感觉十分鬼畜，大概是我还没学正则的时候写的。</p>
<p>星辰那边日常灌水了一篇周报，除了图书推荐<em>《颈椎病防治》</em>以外其他都是xjb扯。昨晚上帮星辰的范老师做了个数据分析，其实也不能算数据分析，就是写个脚本把学号全部对应一下，大概算是数据处理吧*(笑)<em>？下午星辰后端组小会，各位大佬都分享了自己踩的坑，还是挺有趣的。范老师打算做一个类似</em>在武大*那样的微信小程序，顺手我就给之前写的小程序后端代码加了GPL v3。</p>
<p>把手机里的照片全备份出来，然后全部删了。手机内存确实小，很惨啊，QQ和微信太毒瘤了。</p>
]]></content>
      <tags>
        <tag>周小记</tag>
      </tags>
  </entry>
  <entry>
    <title>周小记2018-11-03</title>
    <url>/2018/11/03/%E5%91%A8%E5%B0%8F%E8%AE%B02018-11-03/</url>
    <content><![CDATA[<p>这周把川师那个项目写完了，埋了点坑，没有清除数据库内容。不过按每天不到500条算的话存个几年应该是绰绰有余的，至于性能会不会很慢就不知道了，到时候再优化吧。赚了300块。</p>
<p>星辰那边范老师的数据整合搞定了，其实无非就是拿Python做点基本的处理。有个关于小程序的小会，不过那天忘了，就没去。</p>
<p>胸口刺痛那个情况，最终还是没抽时间去医院，虽然现在感觉好点了，希望不是大问题吧，还想活着。</p>
<p>这周看了下<a href="http://v3.docute.org/">docute</a>，其实主要是<a href="http://cqhttp.cc/">coolq-http-api</a>用了这个，感觉挺不错的，十分简洁，就用了。</p>
]]></content>
      <tags>
        <tag>周小记</tag>
      </tags>
  </entry>
  <entry>
    <title>周小记2018-11-11</title>
    <url>/2018/11/11/%E5%91%A8%E5%B0%8F%E8%AE%B02018-11-11/</url>
    <content><![CDATA[<p>双十一，基本上啥都没买。之前买了个漫步者的防水蓝牙耳机，想洗澡用，不过没用几下就坏了，所以就退了。本周考试，英语作业也有一堆。和王去看了《毒液》，以后看电影一定买前排的位子。感觉眼睛不太行，还是要戴眼镜了。关于瞳孔收缩时候的眼睛疼，有空还是去医院看看吧。考试前一天晚上修了小程序后端的一个bug，自己造轮子确实容易出问题。</p>
]]></content>
      <tags>
        <tag>周小记</tag>
      </tags>
  </entry>
  <entry>
    <title>在PX4Flow上使用HC-SR04</title>
    <url>/2019/07/14/%E5%9C%A8PX4Flow%E4%B8%8A%E4%BD%BF%E7%94%A8HC-SR04/</url>
    <content><![CDATA[<p>参照<a href="https://blog.csdn.net/hxudhdjuf/article/details/79671892">https://blog.csdn.net/hxudhdjuf/article/details/79671892</a></p>
<p>因为上面那个文章写的很乱，代码也不怎么规范，这里记录一下，顺便给后人排坑。</p>
<p>在校队的时候申了一块PX4Flow，260多不带超声波，真特么贵，超声波要260多，原版的超声波型号是MB1240（这里给出<a href="https://www.maxbotix.com/documents/XL-MaxSonar-EZ_Datasheet.pdf">Datasheet</a>），但不得不说效果真的很好，精度和测距范围都很棒。当然当时我是不知道的是PX4Flow如果不带超声波基本没法工作，代码的话我也看得不是很懂。淘宝上可以搜到300不到的PX4Flow，顺便校队里有一个用Pixhawk的无人机就是用的那个光流模块，当时真TM后悔。</p>
<p>好吧闲话不多说，先给出修改原理。HC-SR04的驱动方法相当简单，就是在Trig引脚给一个脉冲，然后等待Echo引脚电平两次变化读取时间，就是发送和接收到超声波的间隔，根据空气音速就能算出距离。所以这里的思路就是用PX4Flow上的STM32F7单片机GPIO引脚来做驱动。</p>
<p>连接方法如下，Trig接4脚（RX），Echo接2脚（PW），GND和VCC供电，分别可以接7脚和6脚，后面应该有GND和VDD的丝印。</p>
<p>需要修改官方的代码，这里提供<a href="https://github.com/MrThanlon/Flow">我修改之后的代码</a>，具体改了哪可以看commit log，这里就不在描述了，修改的部分是超声波的驱动<code>src/modules/flow/sonar.c</code>，以及在<code>src/modules/flow/module.mk</code>和<code>CMakeLists.txt</code>中加入exti和syscfg。</p>
]]></content>
      <categories>
        <category>航模</category>
        <category>飞控</category>
        <category>光流</category>
      </categories>
      <tags>
        <tag>光流</tag>
      </tags>
  </entry>
  <entry>
    <title>在树莓派上使用SATA设备(ASM1062/ASM1061)</title>
    <url>/2021/01/30/%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E4%BD%BF%E7%94%A8SATA%E8%AE%BE%E5%A4%87-ASM1062-ASM1061/</url>
    <content><![CDATA[<p>众所周知，树莓派4使用的BCM2711拥有一个千兆以太网口，以及一条PCIe2.0 1x，也就是说如果我们把PCIe转接到SATA，就可以用树莓派当NAS了，岂不美哉？</p>
<span id="more"></span>

<p>当然，对于树莓派4B来说，它的PCIe已经分配给了USB3.0，所以我们这次要用的是树莓派CM4，它引出了大多数引脚，包括以太网口和PCIe。如果是自己画板子，要注意PCIe是差分对，需要等长布线，我这里为了方便直接买了官方出的底板，一样的用法。</p>
<p>淘宝上比较便宜的方案是ASM1061/ASM1062，这俩都能引出两个SATA口，而且Linux已经包含了它的驱动程序，直接就能使用。关于这玩意的讨论可以看看<a href="https://github.com/geerlingguy/raspberry-pi-pcie-devices/issues/30">这个issue</a>。</p>
<p>买到这个卡之后直接插上开机，输入<code>lspci</code>就直接能看到ASM1062，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> pi@raspberrypi  ~  sudo lspci   </span><br><span class="line">00:00.0 PCI bridge: Broadcom Limited Device 2711 (rev 20)</span><br><span class="line">01:00.0 SATA controller: ASMedia Technology Inc. ASM1062 Serial ATA Controller (rev 01)</span><br></pre></td></tr></table></figure>

<p>但是如果我们直接连上硬盘，可以发现<code>/dev/</code>里面并没有硬盘设备，这是因为树莓派官方的操作系统里面的内核并没有把SATA驱动也编译进去，所以我们只好自己重新编译并安装了。</p>
<p>首先我们需要安装编译需要的工具，如果是在树莓派上编译的话，可以运行以下命令安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install -y git bc bison flex libssl-dev make libncurses5-dev build-essential</span><br></pre></td></tr></table></figure>

<p>如果是在电脑上交叉编译，那就自己看着安装吧。</p>
<p>然后需要克隆linux源码到本地，这里我们使用树莓派基金会维护的linux</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --depth=1 https://github.com/raspberrypi/linux</span><br></pre></td></tr></table></figure>

<p>然后进入到目录进行编译前的配置，首先添加环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export KERNEL=kernel7l</span><br></pre></td></tr></table></figure>

<p>如果是要编译64bit的内核就改成<code>kernel8</code>，32bit就如上<code>kernel7l</code>。</p>
<p>另外如果是在电脑上交叉编译，还需要安装交叉编译器，可以使用<a href="https://github.com/raspberrypi/tools">树莓派仓库</a>里的那个，把bin目录添加到PATH，同时还要添加一个CROSS_COMPILE的环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export CROSS_COMPILE=arm-linux-gnueabihf-</span><br></pre></td></tr></table></figure>

<p>然后deconfig一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make bcm2711_defconfig</span><br></pre></td></tr></table></figure>

<p>然后我们需要修改.config文件，可以用menuconfig来完成，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p>在菜单中找到Device Drivers，按回车进入，找到Serial ATA and Parallel ATA drivers (libata)，按一下空格选中，然后按回车进入里面找到AHCI SATA support，也按一下空格选中。如果你也是ASM106x芯片的卡，那么到这里就完成了，如果是Marvell芯片的，就把Marvell SATA support也加上，在那一行按空格即可，最后保存为.config文件并退出。</p>
<p>如果不想用menuconfig也可以手动修改.config文件，主要是这些地方要修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG_ATA&#x3D;m</span><br><span class="line">CONFIG_ATA_VERBOSE_ERROR&#x3D;y</span><br><span class="line">CONFIG_SATA_PMP&#x3D;y</span><br><span class="line">CONFIG_SATA_AHCI&#x3D;m</span><br><span class="line">CONFIG_SATA_MOBILE_LPM_POLICY&#x3D;0</span><br><span class="line">CONFIG_ATA_SFF&#x3D;y</span><br><span class="line">CONFIG_ATA_BMDMA&#x3D;y</span><br><span class="line">CONFIG_SATA_MV&#x3D;m</span><br></pre></td></tr></table></figure>

<p>最后可以修改下Localversion，在.config文件中找到CONFIG_LOCALVERSION，加个后缀啥的，比如<code>-v7l-sata</code>之类的，然后就可以开始编译啦</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j4 zImage modules dtbs</span><br></pre></td></tr></table></figure>

<p>编译好之后安装替换现在的内核，重启就完事了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make modules_install</span><br><span class="line">sudo cp arch/arm/boot/dts/*.dtb /boot/</span><br><span class="line">sudo cp arch/arm/boot/dts/overlays/*.dtb* /boot/overlays/</span><br><span class="line">sudo cp arch/arm/boot/dts/overlays/README /boot/overlays/</span><br><span class="line">sudo cp arch/arm/boot/zImage /boot/$KERNEL.img</span><br></pre></td></tr></table></figure>

<p>最后附上我自己用一个SSD测试的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> pi@raspberrypi  ~  sudo fdisk -l &#x2F;dev&#x2F;sda</span><br><span class="line">Disk &#x2F;dev&#x2F;sda: 55.9 GiB, 60022480896 bytes, 117231408 sectors</span><br><span class="line">Disk model: GLOWAY FER60GS3-</span><br><span class="line">Units: sectors of 1 * 512 &#x3D; 512 bytes</span><br><span class="line">Sector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytes</span><br><span class="line">I&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytes</span><br><span class="line"> pi@raspberrypi  ~  sudo smartctl -a &#x2F;dev&#x2F;sda</span><br><span class="line">smartctl 6.6 2017-11-05 r4594 [armv7l-linux-5.4.83-v7l+] (local build)</span><br><span class="line">Copyright (C) 2002-17, Bruce Allen, Christian Franke, www.smartmontools.org</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D; START OF INFORMATION SECTION &#x3D;&#x3D;&#x3D;</span><br><span class="line">Device Model:     GLOWAY FER60GS3-S7</span><br><span class="line">Serial Number:    DA3D05C020ACC0010047</span><br><span class="line">LU WWN Device Id: 5 000000 000000000</span><br><span class="line">Firmware Version: F1AC20</span><br><span class="line">User Capacity:    60,022,480,896 bytes [60.0 GB]</span><br><span class="line">Sector Size:      512 bytes logical&#x2F;physical</span><br><span class="line">Rotation Rate:    Solid State Device</span><br><span class="line">Device is:        Not in smartctl database [for details use: -P showall]</span><br><span class="line">ATA Version is:   ACS-2 (minor revision not indicated)</span><br><span class="line">SATA Version is:  SATA 3.1, 6.0 Gb&#x2F;s (current: 6.0 Gb&#x2F;s)</span><br><span class="line">Local Time is:    Sat Jan 30 12:39:45 2021 GMT</span><br><span class="line">SMART support is: Available - device has SMART capability.</span><br><span class="line">SMART support is: Enabled</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D; START OF READ SMART DATA SECTION &#x3D;&#x3D;&#x3D;</span><br><span class="line">SMART overall-health self-assessment test result: PASSED</span><br><span class="line"></span><br><span class="line">General SMART Values:</span><br><span class="line">Offline data collection status:  (0x00)	Offline data collection activity</span><br><span class="line">					was never started.</span><br><span class="line">					Auto Offline Data Collection: Disabled.</span><br><span class="line">Self-test execution status:      (   0)	The previous self-test routine completed</span><br><span class="line">					without error or no self-test has ever </span><br><span class="line">					been run.</span><br><span class="line">Total time to complete Offline </span><br><span class="line">data collection: 		(    0) seconds.</span><br><span class="line">Offline data collection</span><br><span class="line">capabilities: 			 (0x71) SMART execute Offline immediate.</span><br><span class="line">					No Auto Offline data collection support.</span><br><span class="line">					Suspend Offline collection upon new</span><br><span class="line">					command.</span><br><span class="line">					No Offline surface scan supported.</span><br><span class="line">					Self-test supported.</span><br><span class="line">					Conveyance Self-test supported.</span><br><span class="line">					Selective Self-test supported.</span><br><span class="line">SMART capabilities:            (0x0002)	Does not save SMART data before</span><br><span class="line">					entering power-saving mode.</span><br><span class="line">					Supports SMART auto save timer.</span><br><span class="line">Error logging capability:        (0x01)	Error logging supported.</span><br><span class="line">					General Purpose Logging supported.</span><br><span class="line">Short self-test routine </span><br><span class="line">recommended polling time: 	 (   1) minutes.</span><br><span class="line">Extended self-test routine</span><br><span class="line">recommended polling time: 	 (   1) minutes.</span><br><span class="line">Conveyance self-test routine</span><br><span class="line">recommended polling time: 	 (   1) minutes.</span><br><span class="line">SCT capabilities: 	       (0x003d)	SCT Status supported.</span><br><span class="line">					SCT Error Recovery Control supported.</span><br><span class="line">					SCT Feature Control supported.</span><br><span class="line">					SCT Data Table supported.</span><br><span class="line"></span><br><span class="line">SMART Attributes Data Structure revision number: 1</span><br><span class="line">Vendor Specific SMART Attributes with Thresholds:</span><br><span class="line">ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE</span><br><span class="line">  1 Raw_Read_Error_Rate     0x0000   100   100   000    Old_age   Offline      -       0</span><br><span class="line">  5 Reallocated_Sector_Ct   0x0000   100   100   000    Old_age   Offline      -       1</span><br><span class="line">  9 Power_On_Hours          0x0000   100   100   000    Old_age   Offline      -       149</span><br><span class="line"> 12 Power_Cycle_Count       0x0000   100   100   000    Old_age   Offline      -       690</span><br><span class="line">160 Unknown_Attribute       0x0000   100   100   000    Old_age   Offline      -       0</span><br><span class="line">161 Unknown_Attribute       0x0000   100   100   000    Old_age   Offline      -       58</span><br><span class="line">163 Unknown_Attribute       0x0000   100   100   000    Old_age   Offline      -       20</span><br><span class="line">164 Unknown_Attribute       0x0000   100   100   000    Old_age   Offline      -       28663</span><br><span class="line">165 Unknown_Attribute       0x0000   100   100   000    Old_age   Offline      -       101</span><br><span class="line">166 Unknown_Attribute       0x0000   100   100   000    Old_age   Offline      -       0</span><br><span class="line">167 Unknown_Attribute       0x0000   100   100   000    Old_age   Offline      -       55</span><br><span class="line">168 Unknown_Attribute       0x0000   100   100   000    Old_age   Offline      -       3000</span><br><span class="line">169 Unknown_Attribute       0x0000   100   100   000    Old_age   Offline      -       99</span><br><span class="line">175 Program_Fail_Count_Chip 0x0000   100   100   000    Old_age   Offline      -       7</span><br><span class="line">176 Erase_Fail_Count_Chip   0x0000   100   100   000    Old_age   Offline      -       0</span><br><span class="line">177 Wear_Leveling_Count     0x0000   100   100   050    Old_age   Offline      -       0</span><br><span class="line">178 Used_Rsvd_Blk_Cnt_Chip  0x0000   100   100   000    Old_age   Offline      -       1</span><br><span class="line">181 Program_Fail_Cnt_Total  0x0000   100   100   000    Old_age   Offline      -       7</span><br><span class="line">182 Erase_Fail_Count_Total  0x0000   100   100   000    Old_age   Offline      -       0</span><br><span class="line">192 Power-Off_Retract_Count 0x0000   100   100   000    Old_age   Offline      -       55</span><br><span class="line">194 Temperature_Celsius     0x0000   100   100   000    Old_age   Offline      -       24</span><br><span class="line">195 Hardware_ECC_Recovered  0x0000   100   100   000    Old_age   Offline      -       282</span><br><span class="line">196 Reallocated_Event_Count 0x0000   100   100   016    Old_age   Offline      -       0</span><br><span class="line">197 Current_Pending_Sector  0x0000   100   100   000    Old_age   Offline      -       0</span><br><span class="line">198 Offline_Uncorrectable   0x0000   100   100   000    Old_age   Offline      -       0</span><br><span class="line">199 UDMA_CRC_Error_Count    0x0000   100   100   050    Old_age   Offline      -       0</span><br><span class="line">232 Available_Reservd_Space 0x0000   100   100   000    Old_age   Offline      -       98</span><br><span class="line">241 Total_LBAs_Written      0x0000   100   100   000    Old_age   Offline      -       52988</span><br><span class="line">242 Total_LBAs_Read         0x0000   100   100   000    Old_age   Offline      -       70158</span><br><span class="line">245 Unknown_Attribute       0x0000   100   100   000    Old_age   Offline      -       114652</span><br><span class="line"></span><br><span class="line">SMART Error Log Version: 1</span><br><span class="line">No Errors Logged</span><br><span class="line"></span><br><span class="line">SMART Self-test log structure revision number 1</span><br><span class="line">No self-tests have been logged.  [To run self-tests, use: smartctl -t]</span><br><span class="line"></span><br><span class="line">SMART Selective self-test log data structure revision number 1</span><br><span class="line"> SPAN  MIN_LBA  MAX_LBA  CURRENT_TEST_STATUS</span><br><span class="line">    1        0        0  Not_testing</span><br><span class="line">    2        0        0  Not_testing</span><br><span class="line">    3        0        0  Not_testing</span><br><span class="line">    4        0        0  Not_testing</span><br><span class="line">    5        0        0  Not_testing</span><br><span class="line">    6        0    65535  Read_scanning was never started</span><br><span class="line">Selective self-test flags (0x0):</span><br><span class="line">  After scanning selected spans, do NOT read-scan remainder of disk.</span><br><span class="line">If Selective self-test is pending on power-up, resume after 0 minute delay.</span><br></pre></td></tr></table></figure>

<p>读取速度在260MB/s左右，够用了。</p>
]]></content>
      <categories>
        <category>嵌入式开发</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅地开发STM32(Clion,CubeMX,ST-Link)</title>
    <url>/2020/07/25/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%BC%80%E5%8F%91STM32-Clion-CubeMX-ST-Link/</url>
    <content><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>与时髦的应用层码农不同，我们这些嵌入式码农在写单片机程序的时候大多使用上古的Keil，不得不说，Keil确实好用，编译、调试都可以一键完成，但只提供Windows版本，而且界面还停留在上个世纪，也没有自动补全等现代IDE的功能。</p>
<p>自从前段时间换了MacBook Pro之后我就基本上用它来干活了，虚拟机跑Keil实在是得不偿失，更换嵌入式开发环境在所难免。</p>
<span id="more"></span>

<h2 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h2><p>好在ST官方提供的CubeMX支持全平台，免去了SDK的麻烦。</p>
<p>工具链方面GCC本来就是自由软件，macOS上可以直接用Homebrew安装交叉编译器，另外虽然macOS在安装了xcode命令行工具后虽然有<code>gcc</code>命令，但那个实际上是<code>clang</code>，无法用于单片机调试，所以我们还要额外用Homebrew安装GCC，我这里安装的版本是GCC9（截止本文，Homebrew已经可以安装GCC10），调用的命令就是<code>gcc-9</code>，同时获得用于调试的<code>gdb</code>。</p>
<p>同时我们还要安装交叉编译器arm-none-eabi-gcc，<a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">ARM的官网</a>提供了一份macOS的预编译二进制包，直接下载就可以使用。但是，能用包管理的东西，那必然要用包管理呀，PX4飞控的开发者们维护了一份Homebrew的arm-none-eabi-gcc工具链，包含常用版本，可以看看这个<a href="https://github.com/PX4/homebrew-px4">仓库</a>。</p>
<p>ST官方的下载程序STM32CubeProgrammer也是全平台，更棒的是还提供了命令行版本。不过就我个人使用的情况，安装的时候有点问题，官方提供的app文件一点开就闪退，最后我是直接从命令行调用里面的jar包才安装上的。安装好之后就获得了STM32CubeProgrammer，以及它的命令行版本STM32_Programmer_CLI。实际上还有一个开源的下载程序<a href="http://stm32flash.sourceforge.net/">stm32flash</a>，不过它只能用来串口下载，我没有测试，不知道效果如何。另外还可以用OpenOCD来下载程序，这个后面会提到。</p>
<p>以上，工具链的部分就解决了，也就是说原则上我们可以用三大操作系统进行STM32开发，现在我们需要一个优质的IDE，受<a href="http://www.pengzhihui.com/">稚晖大佬</a>的<a href="https://zhuanlan.zhihu.com/p/145801160">文章</a>启发，我决定按照他的方法配置Clion，本文并不会包含与那篇文章有关的内容，因为我这里配置的时候一路顺风，除了下载和调试。</p>
<h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><p>单片机是万金油C8T6，下载和调试使用山寨版ST-Link，淘宝10块钱，macOS免驱，插上就直接识别出来了。</p>
<p>如果觉得自己代码功底很好，完全不需要调试的话也可以使用串口下载，成本更低，整个CH340G就完事了，相关教程不再列出。</p>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="CubeMX"><a href="#CubeMX" class="headerlink" title="CubeMX"></a>CubeMX</h3><p>可以发现要么只能成功下载一次，要么直接就下载不了，OpenOCD提示<code>not connect to target</code>，我搜到了<a href="https://blog.csdn.net/toopoo/article/details/79680323">这篇帖子</a>，按照上面的说法，这是因为PA13和PA14被错误配置，要解决也很简单，在CubeMX中修改SYS设置，SYS-Debug设置为<code>Serial Wire</code>即可。</p>
<p><img src="image-20200725133151700.png" alt="CubeMX配置"></p>
<h3 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h3><p>按照稚晖大佬的教程配置完毕后，我们得到了一个空的STM32源码项目，里面包含HAL以及一些初始化代码，编译也是没有问题的，OpenOCD的配置文件得修改一下。我们用Homebrew安装好OpenOCD之后会得到一些主流开发板、下载器、芯片的cfg文件，他们应该位于<code>/usr/local/share/openocd/scripts</code>，这里对于STM32F103C8T6 + ST-Link的组合，需要两个文件，一个是<code>target/stm32f1x.cfg</code>，还有一个是<code>interface/stlink-v2.cfg</code>（也有一个v1，取决于你用的哪个版本的ST-Link）。我们也可以编写一份cfg，比如<code>board/stm32f103c8t6.cfg</code>，内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source [find interface&#x2F;stlink-v2.cfg]</span><br><span class="line">source [find target&#x2F;stm32f1x.cfg]</span><br></pre></td></tr></table></figure>

<p>非常简单，这样就可以愉快地进行下载和调试了。</p>
<p><img src="image-20200725132334355.png" alt="调试界面"></p>
]]></content>
      <categories>
        <category>嵌入式开发</category>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>嵌入式开发</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅地调用web接口(api.js)</title>
    <url>/2020/06/22/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E8%B0%83%E7%94%A8web%E6%8E%A5%E5%8F%A3-api-js/</url>
    <content><![CDATA[<p>在写前端项目的时候总免不了要调用后端提供的接口，比如POST <code>/user/login</code>，比较传统的方法就是使用XHR。不过，ES6引入了Promise，ES7引入了async/await，使得我们可以更优雅地完成异步操作，于是<a href="https://github.com/axios/axios">axios</a>隆重登场（其实我个人并没有用过axios）。</p>
<span id="more"></span>

<p>主要是受到张大佬的启发，通过</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> api.user.login()</span><br></pre></td></tr></table></figure>

<p>的方式将实际的Web接口封装成一个对象，但是他那个版本做得还不够好，需要事先定义出所有允许调用的接口，然后再处理成一个<code>api</code>对象。</p>
<p>我改进了一下，使用Proxy对象，可以不需要提前定义接口，直接调用即可，这就是现在的<a href="https://gist.github.com/MrThanlon/232ac1eeab73d318a5067ceecbec437a">api.js</a>。</p>
<script src="https://gist.github.com/MrThanlon/232ac1eeab73d318a5067ceecbec437a.js"></script>

<p>说实话，这里的Proxy+递归用的非常花俏，我感觉自己也是抽风了才写出来的。</p>
<p>嘛，总之用法就很简单了，看demo.js的操作。调用的函数可以带参数，如果是一般<code>Object</code>则会以<code>Content-Type: application/json</code>方式发送，如果是<code>FormData</code>则会以<code>Content-Type: multipart/form-data</code>方式发送，超级舒适的。</p>
<h2 id="严重Bug"><a href="#严重Bug" class="headerlink" title="严重Bug"></a><del>严重Bug</del></h2><ul>
<li><del>请求的链接中不能含有<code>/apply/</code>或<code>/apply</code>，否则导致报错，原因是<code>apply</code>是关键字，关于如何规避我还没想到一个合理的写法。</del></li>
</ul>
]]></content>
      <categories>
        <category>Web</category>
        <category>JavaScript</category>
        <category>Proxy</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>小记1</title>
    <url>/2019/11/21/%E5%B0%8F%E8%AE%B01/</url>
    <content><![CDATA[<p>最近头有点胀，主要体现在上课/做题/写代码等需要集中注意力的时候，因为这个导致经常不想做事情，甚至连这篇文章都不太想写，但还是想着要留下点什么。</p>
<p>今天搞了一天的CDN，现在在用的腾讯云，访问<a href="https://blog.ch34k.xyz/">博客</a>应该是没啥问题了。</p>
<p><a href="https://github.com/mrthanlon/kase-be">kase</a>基本上完工。</p>
<p>萌生杯那边队友还在拖，算了反正也不指望什么。</p>
<p>最近咖啡喝的有点多，以后还是节制一些，虽然上课确实没什么打瞌睡的想法了，但是总感觉这玩意就是我头胀的罪魁祸首。</p>
<p>明早第一节没课，今晚大概可以睡得比较舒服了吧，而且明天只有一节课，我甚至可以睡上一天。</p>
<p>好久没有真正意义上的看小说，也许明天可以看一篇短篇。</p>
<p>泰坦不想打了，头晕，眼睛花，也不想玩其他游戏。</p>
]]></content>
      <tags>
        <tag>小记</tag>
      </tags>
  </entry>
  <entry>
    <title>微软2021春招实习生笔试</title>
    <url>/2021/03/06/%E5%BE%AE%E8%BD%AF2021%E6%98%A5%E6%8B%9B%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%AC%94%E8%AF%95/</url>
    <content><![CDATA[<p>两个小时，三道题，第二题实在是粗心了，正确率应该能提到100%的，忘记对结果进行特判。</p>
<p><img src="1FB3584CBBD8AB424975EBD88F150712.jpg" alt="结果"></p>
<h2 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h2><p>第一题可以选择中文或者英文题面，不过题目好像不太一样，我做的中文题。</p>
<span id="more"></span>

<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><blockquote>
<p>给一个数组，求其中元素大于等于3的<strong>等差数列</strong>子串的数量。只评测正确率，不评测运行时间。</p>
</blockquote>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>因为不评测运行时间，所以直接暴力枚举即可，判断是否等差数列可以直接求差分是否相等，复杂度o(n)，枚举子串复杂度C(n,m)，因为每个长度都枚举，总之这个复杂度是挺炸裂的，不过它不评测时间，所以没问题，这题如果认真做的话应该可以优化到o(n)。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isArti</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator begin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr = begin + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> diff = *itr - *begin;</span><br><span class="line">    <span class="keyword">for</span> (; itr &lt; end; itr++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*itr - *(itr - <span class="number">1</span>) != diff) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">artiSeq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">3</span> &lt;= A.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">3</span>; i + len &lt;= A.size(); len++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isArti(A.begin() + i, A.begin() + i + len)) &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><blockquote>
<p>给一个长度N的数组，其中数字范围是[1,N]，每次变化可以对一个元素+1或者-1，求最少多少次变化可以让数组中每个数字唯一。N的范围是2e5。如果结果大于1e9则返回-1。</p>
</blockquote>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>直接排序，然后遍历每个元素求<strong>它本身与它的下标的差</strong>再加起来即可。复杂度o(nlogn)。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>在做这题的时候忘了判断结果是否大于1e9，所以正确率只有90%，裂开。</p>
<p>而且这题其实我搞复杂了，完全不需要那个order数组的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">moveNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    sort(A.begin(), A.end());</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">order</span><span class="params">(A.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; order.size(); i++) &#123;</span><br><span class="line">        order[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">        ans += <span class="built_in">abs</span>(order[i] - A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; <span class="number">1000000000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h2><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><blockquote>
<p>给一组平面上的点，求<strong>三个点共线</strong>的组合有多少个。点的数量范围是1e3，如果结果大于1e9则输出-1。</p>
</blockquote>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>这题没想到好的方法，直接暴力枚举来做的，全部都超时了，好在都是对的。</p>
<p>判断三个点是否共线可以用斜率，具体来说就是<br>$$<br>\frac{x_a-x_b}{y_a-y_b}=\frac{x_c-x_b}{y_c-y_b}<br>$$<br>考虑到除法可能导致精度问题以及除0（垂直线）错误，我们只需要把它改成乘法来判断就好了。复杂度$O(n^3)$。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point2D</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCollinear</span><span class="params">(Point2D &amp;a, Point2D &amp;b, Point2D &amp;c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.x - b.x) * (c.y - b.y) == (c.x - b.x) * (a.y - b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numOfCollinear</span><span class="params">(<span class="built_in">vector</span>&lt;Point2D&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 + <span class="number">2</span> &lt; A.size(); i1++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i2 = i1 + <span class="number">1</span>; i2 + <span class="number">1</span> &lt; A.size(); i2++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i3 = i2 + <span class="number">1</span>; i3 &lt; A.size(); i3++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isCollinear(A[i1], A[i2], A[i3])) &#123;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans &gt; <span class="number">1000000000</span> ? <span class="number">-1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>招聘</category>
        <category>微软</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>微软</tag>
      </tags>
  </entry>
  <entry>
    <title>我自己</title>
    <url>/2019/09/14/%E6%88%91%E8%87%AA%E5%B7%B1/</url>
    <content><![CDATA[<p>不知道是什么时候开始，情绪变得不敏感，在上大学之后达到了质变，既不关心自己也不关心别人，如果是懒得回复的消息，甚至都不想打开看一下。</p>
<p>我曾经很喜欢编程，也喜欢刷算法题，但是现在一打开IDE就本能地想逃避，严重的时候看代码就头晕。</p>
<p>曾经玩泰坦陨落2玩得风生水起，失败了很气馁，胜利就很开心，能开心到叫出来，现在虽然胜率已经超过50%，但是也失去了那种感觉，输了笑一下，赢了也笑一下，好像再平常不过。</p>
<p>高中时候上课看小说，能从上课看到下课，现在有了kindle，也不过是每个月拿出来充下电，真正成了盖泡面神器。</p>
<p>还有好多好多呢，甚至懒得一一列举了。我到底是为什么会失去兴趣、热情的呢？</p>
<p>现在连一些长句子都懒得看下去，知乎上刷到一篇文章如果没有断句，就直接放弃了。</p>
<p>用iphone之前用的是小米4，整天折腾来折腾去，时不时刷个机，或者用公测版系统，每天看有没有更新，又有哪些新功能。到后来也放弃了，直接用稳定版系统，推更新了也懒得去处理，当然现在用iphone就更懒了。</p>
<p>windows10刚发布的时候就给家里电脑装过双系统去体验，甚至还到处帮微软推广来着，现在想想真是可笑呢。换mac之前主力是一台戴尔笔记本，也曾长期使用win10，也有各种魔幻操作去优化，禁用自动更新之类的，在一些“大神”眼里是基本操作的事情。后来也还是因为懒，重装win7一直用到换mac，当然win7确实稳定，没有什么自动更新，系统更新也会明确列出，只是快到服务期限了，所以换mac。</p>
<p>我还记得以前经常会很期待一些东西，比如电影、游戏、数码产品之类的，期待到晚上睡不着觉，想的都是现在能拿到多好啊。有时候确实拿到了，反而有些失望，和自己的期望差太多吧。</p>
<p>大概这就是所谓的佛系青年？或许这是个贬义词，我也懒得去反对了吧。当然这也导致我在选择上更着重于稳定，比如选择完成度较高的产品，github上没有几百个commit的开源软件都不太敢用。现在只觉得，那些折腾来折腾去的事情，其实没有也罢。但是这似乎又陷入了一个矛盾，其实就我个人来说，学习的各类“旁门左道”都是折腾出来的，比如Linux，比如单片机，其实基本都没有系统学习过。</p>
<p>虽然我大概搞清楚了变得佛系的原因，但是看起来我并没有能解决它的方法。有个学长现在在用一系列时间统计工具，对自己各项指标做量化，我觉得没必要，自己的情况自己再清楚不过了，成绩差难道不是因为没听课、没复习、没刷题么？听起来很可笑，但确实是这样，大多数时候我们走错道路，不是因为选择错了，而是我们在知道哪条路正确的时候，同样也知道那条路实在太难走而放弃。</p>
]]></content>
      <tags>
        <tag>人物</tag>
      </tags>
  </entry>
  <entry>
    <title>明日不再来，观众不再有</title>
    <url>/2020/02/21/%E6%98%8E%E6%97%A5%E4%B8%8D%E5%86%8D%E6%9D%A5%EF%BC%8C%E8%A7%82%E4%BC%97%E4%B8%8D%E5%86%8D%E6%9C%89/</url>
    <content><![CDATA[<p>前天刷到<a href="https://www.zhihu.com/question/317945181/answer/680536688">有什么让人听了背脊发凉的恐怖故事？ - 知乎</a>，开局很有意思就一直读下去了，看完回答的时候作者提到后续内容在豆瓣阅读，名字是《恶脑》。根本停不下来，马上下了豆瓣阅读买完整版（6块多），一口气看完，看完的时候已经是晚上十一点。虽然小说有点悬疑和推理，但并不着重于此，看了分类才知道是奇幻。</p>
<p>它让我想起了高中时候看过马广《明日不再来》，当时它在《萌芽》上连载。高中时我浪得很，除了自习课，有时上正课也会看闲书，最初是《读者》《意林》《青年文摘》这样的文摘，然后是《收获》《萌芽》《当代》《人民文学》。我当然没有钱去订阅那么多，所有的这些都感谢柳高读书馆，图书馆里的杂志是三期钉到一起，借一次可以爽差不多一星期。</p>
<p>刘慈欣说他是在值班的时候写小说，有种占便宜的感觉，我那时候应该也是差不多的心理。那是我阅读量突飞猛进的一段时光，现在失去了那种状态，也提不起读文字的兴趣了，每天想的都是写代码或者打游戏，怎么可能会去读书呢？</p>
<p>以上是背景，看完《恶脑》第二天又翻了翻kindle，恍然想起《明日不再来》，《明日》也是带着点悬疑和推理的小说，但是它的情节要更丰富，结局更自然，各个方面都比《恶脑》成熟多了。既然我能看完《恶脑》，为什么不重新看一遍《明日》呢？手贱点开样章，才六块钱，买。</p>
<p>于是一天就没了。</p>
<p>虽然已经知道结局，也多多少少记得一些内容，再看一次还是很有意思。</p>
<p>男主角杜鸣的女朋友董佳萌失踪，六天里杜鸣和佳萌的弟弟董佳世到处寻找佳萌。故事并不长，只有六天，却充实得可怕。虽然说艺术来源于生活而高于生活，但还是不自然地会去对比现实，想想自己这个寒假，太颓废了。我没有女朋友，但是如果我有而且她失踪的话，我想我是一定还是每天该吃吃该喝喝，报个警就完事了，大概不会到处去找线索。</p>
<p>最后放个kindle版的<a href="https://www.amazon.cn/dp/B07KVYZDWZ/ref=sr_1_1?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&keywords=%E6%98%8E%E6%97%A5%E4%B8%8D%E5%86%8D%E6%9D%A5&qid=1582282661&sr=8-1">购买链接</a>。</p>
]]></content>
      <categories>
        <category>灌水</category>
        <category>日常</category>
      </categories>
      <tags>
        <tag>灌水</tag>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组的一个优雅实现（C++）</title>
    <url>/2020/04/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%EF%BC%88C-%EF%BC%89/</url>
    <content><![CDATA[<p>废话不多说，直接上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BIT(<span class="keyword">int</span> _n) : n(_n), tree(_n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询前缀和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            ret += tree[x];</span><br><span class="line">            x -= lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">            tree[x] = v;</span><br><span class="line">            x += lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从leetcode的一个题解里面抄的，构造函数接受一个参数<code>_n</code>表示数组长度，并初始化（为0），做了一些改动，感觉非常舒适。</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li><input disabled="" type="checkbox"> 从数组或者迭代器中初始化</li>
<li><input disabled="" type="checkbox"> 使用模板，不局限于int类型</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>ICPC</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>樱花动画的webgl实现</title>
    <url>/2020/01/13/%E6%A8%B1%E8%8A%B1%E5%8A%A8%E7%94%BB%E7%9A%84webgl%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>来自<a href="https://mc.uestc.app/">LUG的MC网站</a>，感觉很不错，我删掉了一些代码，只保留了canvas的部分。如果看不到的话可以点<a href="https://blog.ch34k.xyz/static_pages/sakura/">这里</a>。</p>
<iframe src="https://blog.ch34k.xyz/static_pages/sakura/index.html" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe>
]]></content>
      <categories>
        <category>Web</category>
        <category>WebGL</category>
      </categories>
      <tags>
        <tag>动画</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次LVM误操作引发的事故</title>
    <url>/2021/01/08/%E8%AE%B0%E4%B8%80%E6%AC%A1LVM%E8%AF%AF%E6%93%8D%E4%BD%9C%E5%BC%95%E5%8F%91%E7%9A%84%E4%BA%8B%E6%95%85/</url>
    <content><![CDATA[<p>总之是闯了大祸，好在最后数据都没事。主要问题是我对LVM操作不熟练，以及对文件系统和磁盘没有比较清晰的认识，具体来说就是我以为<del>LVM在进行lvresize时会自动处理文件系统</del>，这当然是错误的，<strong>文件系统应该使用resize2fs命令来调整，LVM管理的是块设备</strong>，不会处理文件系统上的问题。</p>
<span id="more"></span>

<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>事情的起因是论坛502了，一般是请求量过大，过一会就好了，但是这次一直持续了8分钟，然后我就上服务器看了下，nginx和php都跑着，挂载根目录的磁盘满了，老规矩删日志，删完还剩500M左右，我就想着能不能处理一下，不然不一会儿又满了。</p>
<p>服务器使用了LVM，好像有硬件RAID（但是操作系统上好像没有对应的软件查看），卷组的大小是1.1T左右，分出了三个逻辑卷</p>
<ul>
<li>home卷，总容量1.01T左右，可用802G，挂载到/home目录</li>
<li>root卷，总容量50G，可用空间告急，挂载到根目录</li>
<li>swap分区，总容量31G</li>
</ul>
<p>具体的分配情况如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@guangdian lib]# vgdisplay</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               centos</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence No  4</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                3</span><br><span class="line">  Open LV               3</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               &lt;1.09 TiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              285647</span><br><span class="line">  Alloc PE / Size       285646 / &lt;1.09 TiB</span><br><span class="line">  Free  PE / Size       1 / 4.00 MiB</span><br><span class="line">  VG UUID               4NKz0b-Alp0-gQJF-LmsB-R0JA-0WhR-RCzalL</span><br><span class="line">[root@guangdian lib]# lvdisplay</span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/centos/swap</span><br><span class="line">  LV Name                swap</span><br><span class="line">  VG Name                centos</span><br><span class="line">  LV UUID                fUURt3-Ee42-aOiy-ZnWF-IOfc-aJ7p-JYVfIf</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time guangdian, 2017-12-27 16:32:12 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line"><span class="meta">  #</span><span class="bash"> open                 2</span></span><br><span class="line">  LV Size                &lt;31.44 GiB</span><br><span class="line">  Current LE             8048</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           253:1</span><br><span class="line">   </span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/centos/home</span><br><span class="line">  LV Name                home</span><br><span class="line">  VG Name                centos</span><br><span class="line">  LV UUID                xeRdqP-oCOa-CzK7-V8Si-qjmM-eUYX-cGlj59</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time guangdian, 2017-12-27 16:32:13 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line"><span class="meta">  #</span><span class="bash"> open                 1</span></span><br><span class="line">  LV Size                1.01 TiB</span><br><span class="line">  Current LE             264798</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           253:2</span><br><span class="line">   </span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/centos/root</span><br><span class="line">  LV Name                root</span><br><span class="line">  VG Name                centos</span><br><span class="line">  LV UUID                BPsadR-H2iE-OgiL-t2DB-jL7S-m0Fq-N78Hby</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time guangdian, 2017-12-27 16:32:30 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line"><span class="meta">  #</span><span class="bash"> open                 1</span></span><br><span class="line">  LV Size                50.00 GiB</span><br><span class="line">  Current LE             12800</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           253:0</span><br></pre></td></tr></table></figure>

<p>然后我就抽风了，先用resize2fs压缩，失败，因为文件系统是XFS不支持压缩（另外GFS2也不支持压缩，EXT4支持压缩），但是我没理，直接把home卷给整到300G</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvresize -L 300G /dev/mapper/centos-home </span><br></pre></td></tr></table></figure>

<p>此时LVM发出警告</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  WARNING: Reducing active and open logical volume to 300.00 GiB.</span><br><span class="line">  THIS MAY DESTROY YOUR DATA (filesystem etc.)</span><br><span class="line">Do you really want to reduce centos/home? [y/n]:</span><br></pre></td></tr></table></figure>

<p>我看都没看直接一个y，分配变成了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@guangdian lib]# vgdisplay</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               centos</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence No  5</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                3</span><br><span class="line">  Open LV               3</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               &lt;1.09 TiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              285647</span><br><span class="line">  Alloc PE / Size       97648 / &lt;381.44 GiB</span><br><span class="line">  Free  PE / Size       187999 / 734.37 GiB</span><br><span class="line">  VG UUID               4NKz0b-Alp0-gQJF-LmsB-R0JA-0WhR-RCzalL</span><br><span class="line">[root@guangdian lib]# lvdisplay</span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/centos/swap</span><br><span class="line">  LV Name                swap</span><br><span class="line">  VG Name                centos</span><br><span class="line">  LV UUID                fUURt3-Ee42-aOiy-ZnWF-IOfc-aJ7p-JYVfIf</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time guangdian, 2017-12-27 16:32:12 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line"><span class="meta">  #</span><span class="bash"> open                 2</span></span><br><span class="line">  LV Size                &lt;31.44 GiB</span><br><span class="line">  Current LE             8048</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           253:1</span><br><span class="line">   </span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/centos/home</span><br><span class="line">  LV Name                home</span><br><span class="line">  VG Name                centos</span><br><span class="line">  LV UUID                xeRdqP-oCOa-CzK7-V8Si-qjmM-eUYX-cGlj59</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time guangdian, 2017-12-27 16:32:13 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line"><span class="meta">  #</span><span class="bash"> open                 1</span></span><br><span class="line">  LV Size                300.00 GiB</span><br><span class="line">  Current LE             76800</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           253:2</span><br><span class="line">   </span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/centos/root</span><br><span class="line">  LV Name                root</span><br><span class="line">  VG Name                centos</span><br><span class="line">  LV UUID                BPsadR-H2iE-OgiL-t2DB-jL7S-m0Fq-N78Hby</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time guangdian, 2017-12-27 16:32:30 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line"><span class="meta">  #</span><span class="bash"> open                 1</span></span><br><span class="line">  LV Size                50.00 GiB</span><br><span class="line">  Current LE             12800</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           253:0</span><br></pre></td></tr></table></figure>

<p>然后把root卷修改到200G</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvresize -L 200G /dev/mapper/centos-root</span><br></pre></td></tr></table></figure>

<p>分配变成了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@guangdian lib]# lvdisplay</span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/centos/swap</span><br><span class="line">  LV Name                swap</span><br><span class="line">  VG Name                centos</span><br><span class="line">  LV UUID                fUURt3-Ee42-aOiy-ZnWF-IOfc-aJ7p-JYVfIf</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time guangdian, 2017-12-27 16:32:12 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line"><span class="meta">  #</span><span class="bash"> open                 2</span></span><br><span class="line">  LV Size                &lt;31.44 GiB</span><br><span class="line">  Current LE             8048</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           253:1</span><br><span class="line">   </span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/centos/home</span><br><span class="line">  LV Name                home</span><br><span class="line">  VG Name                centos</span><br><span class="line">  LV UUID                xeRdqP-oCOa-CzK7-V8Si-qjmM-eUYX-cGlj59</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time guangdian, 2017-12-27 16:32:13 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line"><span class="meta">  #</span><span class="bash"> open                 1</span></span><br><span class="line">  LV Size                300.00 GiB</span><br><span class="line">  Current LE             76800</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           253:2</span><br><span class="line">   </span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/centos/root</span><br><span class="line">  LV Name                root</span><br><span class="line">  VG Name                centos</span><br><span class="line">  LV UUID                BPsadR-H2iE-OgiL-t2DB-jL7S-m0Fq-N78Hby</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time guangdian, 2017-12-27 16:32:30 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line"><span class="meta">  #</span><span class="bash"> open                 1</span></span><br><span class="line">  LV Size                200.00 GiB</span><br><span class="line">  Current LE             51200</span><br><span class="line">  Segments               2</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           253:0</span><br></pre></td></tr></table></figure>

<p>直到这时我才发现home卷出问题了，/home无法访问，提示输入输出错误，然后尝试回滚，将分配情况尽可能改回原来的状态，先把多分配给root卷的部分改回去，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvresize -L 50GB /dev/mapper/centos-root</span><br></pre></td></tr></table></figure>

<p>然后把home卷也改回去，但是我这里失误了，命令是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvresize -L 802GB /dev/mapper/centos-home</span><br></pre></td></tr></table></figure>

<p>不应该是802G，而是1.01T左右，然后我又执行了命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvresize -L 1.01TiB /dev/mapper/centos-home</span><br></pre></td></tr></table></figure>

<p>然后中途网络波动，ssh断了，服务器是仅公钥登陆，在无法访问/home的情况下，我远程登不上，只能进机房操作了。</p>
<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>当时我在准备DSP和高频的考试，是豆豆帮我去沙河机房把磁盘整个拷贝了出来，十分感谢豆豆的帮助。</p>
<p>然后我们是在一台Debian Live CD的系统上尝试恢复的。将磁盘镜像挂载到回环设备上之后，LVM识别到了卷组。</p>
<p>重新整理一下上面操作过程对LVM的影响，好在VG分配是线性的，用LE（logical extent）作为单位精确描述一下，</p>
<ol start="0">
<li>初始<ul>
<li>swap: 8048, [0, 8047]</li>
<li>home: 264798, [8048, 272845]</li>
<li>root: 12800, [272846, 285645]</li>
</ul>
</li>
<li>第一次lvresize命令，home压缩到300G<ul>
<li>swap: 同上</li>
<li>home: 76800, [8048, 84847]</li>
<li>root: 同上</li>
</ul>
</li>
<li>第二次lvresize命令，root扩展到200G<ul>
<li>swap: 同上</li>
<li>home: 同上</li>
<li>root: 大小从12800变成51200，增加了38400，即加上了一个段[84847, 123246]</li>
</ul>
</li>
<li>第三次lvresize命令，root还原回50G<ul>
<li>swap: 同上</li>
<li>home: 同上</li>
<li>root: 还原到12800，返回到第一次lvresize时候的状况</li>
</ul>
</li>
<li>第四次lvresize命令，home变为802G<ul>
<li>swap: 同上</li>
<li>home: 因为没有查看分配情况，实际是啥不得而知</li>
<li>root: 同上</li>
</ul>
</li>
<li>第五次lvresize命令，home变为1.01T<ul>
<li>swap: 同上</li>
<li>home: 在之后从磁盘镜像中看到的情况来看，LE数量为264766，[8048, 272813]，相比最初的分配情况少了32个LE</li>
<li>root: 不变</li>
</ul>
</li>
</ol>
<p>具体过程就是这样了，考虑到并没有执行xfs_growfs，应该没有额外的数据被写入到不适合的位置，所以最后直接将home改回原来的位置应该就行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvresize -L +32 /dev/mapper/centos-home</span><br></pre></td></tr></table></figure>

<p>服务器重启之后/home能正常访问，网站也恢复了。</p>
<p>这部分是在涛哥的指导下进行的，包括整个过程的分析，以及最后的+32，感谢涛哥对我的忍耐。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为运维，应该要明确知道敲下的命令会发生什么，会有什么严重后果，如果确实不清楚，就去看手册、搜索引擎。如果无法避免严重的后果，就应该备份好重要数据。</p>
]]></content>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>小记</tag>
        <tag>LVM</tag>
      </tags>
  </entry>
  <entry>
    <title>锻炼你的计算力！</title>
    <url>/2019/03/14/%E9%94%BB%E7%82%BC%E4%BD%A0%E7%9A%84%E8%AE%A1%E7%AE%97%E5%8A%9B%EF%BC%81/</url>
    <content><![CDATA[<div id="pages" style="font-family:Consolas;">
<span></span>&nbsp;+&nbsp;<span></span>&nbsp;×&nbsp;<span></span><input id="innum" type="number" onkeyup="doaction()" v-model="ans"/><br /><span class="label label-success" style="font-size:1em;">&nbsp;Accepted</span>&nbsp;<span class="label label-danger" style="font-size:1em;">&nbsp;Wrong Answer</span>
</div>
<script src="">
</script>

]]></content>
      <tags>
        <tag>小功能</tag>
      </tags>
  </entry>
  <entry>
    <title>清水时光小程序后端开发日志</title>
    <url>/2019/01/27/%E6%B8%85%E6%B0%B4%E6%97%B6%E5%85%89%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="UESTClife小程序后端开发日志"><a href="#UESTClife小程序后端开发日志" class="headerlink" title="UESTClife小程序后端开发日志"></a>UESTClife小程序后端开发日志</h1><p>这并不是readme，而是灌水用的日记。<br>请不要指望在此找到任何有价值的内容。<br>接口文档去看API.md。</p>
<h2 id="2019-01-27"><a href="#2019-01-27" class="headerlink" title="2019-01-27"></a>2019-01-27</h2><p>idas更新了，现在登录提交的表单中密码会经过加密，加密方式应该是<code>AES-128-CBC</code>，然后用base64编码。</p>
<p>密钥就在获取的HTML上，一个script标签里面，变量名是<code>pwdDefaultEncryptSalt</code>，那个标签里面还有个<code>secure=&quot;false&quot;</code>我不是很清楚什么意思，貌似也没有用到。</p>
<p>明文前部是64字节的随机字符串接上密码字符串，iv随机指定一个16字节的字符串就行。</p>
<h2 id="2019-01-20"><a href="#2019-01-20" class="headerlink" title="2019-01-20"></a>2019-01-20</h2><p>放假回家啦。</p>
<p>现在可以发现的是一卡通登录失败，历史遗留问题，一卡通使用老的接口登录，而不是统一验证。神奇的是一卡通网站的密码和统一验证用的不是同一套系统。现在决定重写一卡通登录模块，用统一验证的入口。</p>
<p>根据抓包分析的结果，请求的URL应该是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;idas.uestc.edu.cn&#x2F;authserver&#x2F;login?service&#x3D;http%3A%2F%2Fecard.uestc.edu.cn%2Fcaslogin.jsp</span><br></pre></td></tr></table></figure>

<p>这个</p>
<h2 id="2018-12-22"><a href="#2018-12-22" class="headerlink" title="2018-12-22"></a>2018-12-22</h2><p>全部重构完毕，暂时没有接入研究生系统。顺带修复了<code>grade.php</code>无法获取成绩总览的bug和<code>check_token.php</code>无法检测教务处的bug。</p>
<p>同时更新了下服务器端的配置文件。</p>
<h2 id="2018-12-19"><a href="#2018-12-19" class="headerlink" title="2018-12-19"></a>2018-12-19</h2><p>准备接入研究生系统，又要挖接口了。</p>
<blockquote>
<p>登录接口  </p>
<p>删除Cookie后可能导致需要重新设置密保，具体原因不明。</p>
<p>注意下面两个方法使用的密码可能是不同的，这里有疑问，具体等老哥答复。</p>
<p>方法一：使用独立登录页面，需要验证码</p>
<ol>
<li>GET<code>http://yjsjy.uestc.edu.cn/pyxx/account/login</code>，获得一个Cookie，<code>JSESSIONID</code></li>
<li>请求验证码，GET<code>http://yjsjy.uestc.edu.cn/pyxx/captcha/imageCode</code></li>
<li>登录，POST<code>http://yjsjy.uestc.edu.cn/pyxx/account/logon</code>，带表单，四个键值对：<ul>
<li><code>targetUrl</code>=””</li>
<li><code>username</code>=”学号”</li>
<li><code>password</code>=”密码”</li>
<li><code>captcha</code>=”验证码”  </li>
</ul>
</li>
<li>完成，如果跳转到<code>/pyxx/home/index</code>就是登录成功了，登录失败则是跳转到<code>/pyxx/account/login?error=x</code>，x为错误的类型：<ul>
<li>1=密码错误</li>
<li>2=学号不存在</li>
<li>3=验证码有误</li>
<li>4=请先在迎新系统进行学院报道</li>
</ul>
</li>
</ol>
<p>方法二：使用统一登录(idas)，先登录<code>portal</code>，再登录<code>yjsjy</code>，不需要验证码。</p>
</blockquote>
<blockquote>
<p>成绩接口：</p>
<p>GET<code>http://yjsjy.uestc.edu.cn/pyxx/pygl/cjcx</code></p>
</blockquote>
<blockquote>
</blockquote>
<h2 id="2018-12-17"><a href="#2018-12-17" class="headerlink" title="2018-12-17"></a>2018-12-17</h2><p>打算先搞定JWT部分，顺便整理一下错误码。</p>
<h2 id="2018-12-16"><a href="#2018-12-16" class="headerlink" title="2018-12-16"></a>2018-12-16</h2><p>差不多可以启动重构了，使用JWT标准，使用比较标准的日志记录，在抛异常的时候记录更多有用的信息便于排错，区分error和warning。</p>
<p>开了个用于重构的分支，revision1。</p>
<h2 id="2018-12-13"><a href="#2018-12-13" class="headerlink" title="2018-12-13"></a>2018-12-13</h2><p>学号2018091613028，考试信息读取不到。</p>
<p>好像是可以获取的，大概是用户没有清除缓存。</p>
<h2 id="2018-12-08"><a href="#2018-12-08" class="headerlink" title="2018-12-08"></a>2018-12-08</h2><p>修复了check_token.php的问题，idas那个页面居然重定向了80多次，不知道那个zz写的。</p>
<h2 id="2018-12-07"><a href="#2018-12-07" class="headerlink" title="2018-12-07"></a>2018-12-07</h2><p>学号2018091613028，课程表和注册信息读取不到。</p>
<p>已修复，URL发生一些变化，打了个临时补丁修复了。</p>
<h2 id="2018-12-03"><a href="#2018-12-03" class="headerlink" title="2018-12-03"></a>2018-12-03</h2><p>课程表接口失效，体现为请求结果为空，开始抢修。</p>
<h2 id="2018-11-08"><a href="#2018-11-08" class="headerlink" title="2018-11-08"></a>2018-11-08</h2><p>学校升级了统一验证页面，现在需要重写eams登录和idas登录。</p>
<h2 id="2018-11-05"><a href="#2018-11-05" class="headerlink" title="2018-11-05"></a>2018-11-05</h2><p>稍微修改了下接口文档的格式，然后放到网站上。<a href="https://ch34k.xyz/docs/UESTC-Miniapp-Backend/API%E3%80%82">https://ch34k.xyz/docs/UESTC-Miniapp-Backend/API。</a></p>
<h2 id="2018-10-29"><a href="#2018-10-29" class="headerlink" title="2018-10-29"></a>2018-10-29</h2><p>把check_token.php干了，<br>现在当静态文件用，只返回</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;success&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个后期我会解决，<br>另外就是下次准备用Guzzle重构，<br>替换掉使用了url.php的部分。<br>原来<em>http for human</em>在php也是存在的！！</p>
<h2 id="2018-10-28"><a href="#2018-10-28" class="headerlink" title="2018-10-28"></a>2018-10-28</h2><p>check_token出现迷之错误，<br>get请求返回null，<br>用postman则正常。</p>
<h2 id="2018-10-12"><a href="#2018-10-12" class="headerlink" title="2018-10-12"></a>2018-10-12</h2><p>用Exception重写了login.php，<br>有种优雅了许多的错觉。<br>工作量似乎比我预想的小一些？</p>
<p>顺便跟新了接口文档，<br>加入status功能。</p>
<h2 id="2018-10-10"><a href="#2018-10-10" class="headerlink" title="2018-10-10"></a>2018-10-10</h2><p>试一下做个自动部署。</p>
<p>顺便还有那个login接口的status也要搞定，<br>心累。</p>
<h2 id="2018-10-09"><a href="#2018-10-09" class="headerlink" title="2018-10-09"></a>2018-10-09</h2><p>再次修复history.php中json字符串错乱。<br>对php的数组了解不够透彻，<br>还需要深入学习。<br>API更新了注册信息模块，<br>这里爬取方式。</p>
<p>请求方式为GET，URL是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;eams.uestc.edu.cn&#x2F;eams&#x2F;registerApply!search.action</span><br></pre></td></tr></table></figure>
<p>带一个参数<code>_</code>，<br>参数值为unix时间戳（毫秒）。<br>请求得到的字符串为HTML代码，<br>表格的内容就在第三个<code>tbody</code>标签里面，<br>直接上正则就行。</p>
<p>注册信息开发完成，<br>貌似这玩意只是当个装饰？<br>服了老哥了。</p>
<h2 id="2018-10-08"><a href="#2018-10-08" class="headerlink" title="2018-10-08"></a>2018-10-08</h2><p>修复了history响应中array变object的问题。</p>
<p>以后写完代码还是得测试才行啊。</p>
<h2 id="2018-10-07"><a href="#2018-10-07" class="headerlink" title="2018-10-07"></a>2018-10-07</h2><p>啊，国庆假期结束啦。</p>
<p>在ecard/info.php里面把名字加上了。</p>
<h2 id="2018-09-24"><a href="#2018-09-24" class="headerlink" title="2018-09-24"></a>2018-09-24</h2><p>今天大概可以把交易流水搞定吧。<br>顺便修改下接口文档。<br>请求URL为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ecard.uestc.edu.cn&#x2F;web&#x2F;guest&#x2F;personal?</span><br></pre></td></tr></table></figure>
<p>方式是POST，带一堆参数：</p>
<ul>
<li><code>p_p_id=transDtl_WAR_ecardportlet</code></li>
<li><code>p_p_lifecycle=0</code></li>
<li><code>p_p_state=exclusive</code></li>
<li><code>p_p_mode=view</code></li>
<li><code>p_p_col_id=column-4</code></li>
<li><code>p_p_col_count=1</code></li>
<li><code>_transDtl_WAR_ecardportlet_action=dtlmoreview</code></li>
</ul>
<p>都是固定的。<br>还带一个表单，完整版如下：</p>
<ul>
<li><code>_transDtl_WAR_ecardportlet_cur</code>=页数</li>
<li><code>_transDtl_WAR_ecardportlet_delta</code>=总页数</li>
<li><code>_transDtl_WAR_ecardportlet_qdate</code>=查询时间（7|30|60|180）</li>
<li><code>_transDtl_WAR_ecardportlet_qtype</code>=交易类型（1=充值|2=消费|3=易支付电控）</li>
</ul>
<p>差不多就这样，另外查第一页不用前面两个。</p>
<p>写完了。<br>教务处网站又双叒叕挂了，<br>现在不好测试，先放着不推了。</p>
<h2 id="2018-09-19"><a href="#2018-09-19" class="headerlink" title="2018-09-19"></a>2018-09-19</h2><p>更新了.gitignore，<br>以后有空还是做一下git推送自动部署，<br>每次ssh感觉还是挺麻烦的。<br>当然搞定samba然后直接把工程文件放上去就更好了。</p>
<p>三个图表的接口搞定了，<br>下一步是那个比较麻烦的交易流水。<br>最近还是懒得做重构，<br>毕竟能跑就行（笑），<br>而且把验证放过去还会降低性能。<br>比较有必要的是login.php的多线程，<br>可以把登录速度加快点。</p>
<p>靠，出问题了，<br>不能直接返回过去，<br>得放到json中的data部分，<br>靠。<br>已解决。</p>
<h2 id="2018-09-18"><a href="#2018-09-18" class="headerlink" title="2018-09-18"></a>2018-09-18</h2><p>一卡通的登录会经过一个跳转到idas，<br>然后再跳转回来，<br>这一过程中会进行Set-Cookie。<br>关键是跳转特别快，这就有点坑了。</p>
<p>用postman直接请求会读取到一卡通登录页面，<br>postman有重定向自动跟随，<br>但是浏览器打开则会跳转到统一认证，<br>也就是说这里的跳转是通过js实现的，<br>把浏览器的js关掉后没有发生跳转也说明了这点。</p>
<p>另外可以确定的一点是，<br>登录idas之后会发生302跳转到ecard，<br>链接中有个参数为ticket，<br>似乎就是用这个参数来实现跨站验证的。<br>而且跳转过去的时候一定要快，<br>否则报500错误。<br>但是从请求的结果来看，<br>十分奇怪。<br>带ticket的URL请求，<br>没有任何Set-Cookie，<br>而浏览器会携带几个cookie。<br>我的理解是，<br>第一次请求的时候设置了cookie，<br>然后ticket作为一个激活码，<br>学校后端接到这个激活码后将原来的cookie生效。</p>
<p>不过我又试了下关闭js的时候，<br>一卡通页面依然可以通过表单的POST请求来登录。<br>如果这样登录不影响其他cookie，<br>那么就决定使用这个方式来登录一卡通。<br>一卡通有三个cookie</p>
<ul>
<li><code>COOKIE_SUPPORT=true</code></li>
<li><code>GUEST_LANGUAGE_ID=zh_CN</code></li>
<li><code>JSESSIONID=...</code>这个应该就是用于验证的了</li>
</ul>
<p>其中<code>JSESSIONID</code>会在请求<code>http://ecard.uestc.edu.cn/</code>的时候设置。<br>登录时候POST的URL是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ecard.uestc.edu.cn&#x2F;c&#x2F;portal&#x2F;login</span><br></pre></td></tr></table></figure>
<p>登录时候提交的表单有三个数据</p>
<ul>
<li><code>_58_login_type=_58_login_type</code></li>
<li><code>_58_login</code>学号</li>
<li><code>_58_password</code>密码</li>
</ul>
<p>如果登录成功的话会302跳转到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ecard.uestc.edu.cn&#x2F;web&#x2F;guest&#x2F;personal</span><br></pre></td></tr></table></figure>
<p>并且会设置新的<code>JSESSIONID</code>并加上一个<code>GUEST_LANGUAGE_ID=zh_CN</code>  </p>
<p>如果登录失败则一般会跳转到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.254.154&#x2F;web&#x2F;guest&#x2F;index?_yktlogin_WAR_ecardportlet_err&#x3D;1</span><br></pre></td></tr></table></figure>
<p>这里做个判断就可以。</p>
<p>再次感觉到重构的必要了，<br>有必要用上异常处理，<br>免得返回的内容不准确，<br>写得像坨shit。</p>
<p>忘了说了，读取一卡通信息的URL是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ecard.uestc.edu.cn&#x2F;web&#x2F;guest&#x2F;personal</span><br></pre></td></tr></table></figure>
<h2 id="2018-09-17"><a href="#2018-09-17" class="headerlink" title="2018-09-17"></a>2018-09-17</h2><p>突然发现似乎要登录一卡通了，<br>也就是<code>ecard.uestc.edu.cn</code>这个域名。<br>所以login.php和check_token.php可能要新增代码了。</p>
<h2 id="2018-09-16"><a href="#2018-09-16" class="headerlink" title="2018-09-16"></a>2018-09-16</h2><p>正式开始写一卡通部分，这一块内容有点多，可能要放缓了。前端部分估计工作量也比较大，今年内应该没法上线。</p>
<p>写一下内容吧，以下几点（突然学起领导的口气了呢）</p>
<ul>
<li>一卡通信息，包括卡号，余额，状态等</li>
<li>交易流水，明细</li>
<li>消费趋势</li>
<li>消费地点</li>
<li>充值趋势</li>
</ul>
<p>最后三点就是“我的活动”里面的那三个图，分别对应三个POST，响应都是json，基本上直接发回去就行，URL都是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ecard.uestc.edu.cn&#x2F;web&#x2F;guest&#x2F;myactive</span><br></pre></td></tr></table></figure>
<p>包含8个链接参数</p>
<ul>
<li><code>p_p_id=myActive_WAR_ecardportlet</code></li>
<li><code>p_p_lifecycle=2</code></li>
<li><code>p_p_state=normal</code></li>
<li><code>p_p_mode=view</code></li>
<li><code>p_p_resource_id</code>有三个值，<br><code>consumeStat</code>,<code>consumeComp</code>,<code>dpsStat</code>，<br>分别对应三张表的数据。</li>
<li><code>p_p_cacheability=cacheLevelPage</code></li>
<li><code>p_p_col_id=column-1</code></li>
<li><code>p_p_col_count=1</code></li>
</ul>
<p>以及一个Form-Data</p>
<ul>
<li><code>_myActive_WAR_ecardportlet_days=30</code></li>
</ul>
<p>前面两个就从页面获取，信息没什么说的，老样子。交易明细是一个HTML table，在后端做解析json再发回。因为学长的需求，就把一卡通部分的接口都放到一个目录下。  </p>
<p>是时候重构一波了，复用验证请求和token部分的代码。  </p>
<p>一卡通信息比较好做，就先做这个。</p>
<h2 id="2018-09-11"><a href="#2018-09-11" class="headerlink" title="2018-09-11"></a>2018-09-11</h2><p>个人信息部分写完了，<br>简单测试了一下，貌似没有问题。<br>有时间重构一下，<br>可以复用验证的部分。</p>
<h2 id="2018-09-10"><a href="#2018-09-10" class="headerlink" title="2018-09-10"></a>2018-09-10</h2><p>教师节，苦逼军训，呵呵。<br>准备添加个人信息功能，<br>URL如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;eams.uestc.edu.cn&#x2F;eams&#x2F;stdDetail.action?_&#x3D;</span><br></pre></td></tr></table></figure>
<p>请求方式为GET，<br>带一个参数<code>_</code>，<br>参数值为当前时间(unix时间戳，毫秒)。<br>请求需要cookie，应该只用两个就行</p>
<ul>
<li><code>JSESSIONID</code></li>
<li><code>iPlanetDirectoryPro</code></li>
</ul>
<p>返回的数据主要是HTML的表格，<br>老样子，正则大法好。</p>
<h2 id="2018-09-05"><a href="#2018-09-05" class="headerlink" title="2018-09-05"></a>2018-09-05</h2><p>这几天在军训，比较严，没有拿笔记本出来。<br>目前考试信息出现bug，<br>体现为出现空键，<br>猜测是数组越界。<br>目前问题已经解决，并且更新了文档。</p>
<h2 id="2018-09-02"><a href="#2018-09-02" class="headerlink" title="2018-09-02"></a>2018-09-02</h2><p>现在出了一个问题，<br>就是我自己的课表总是爬不出来。<br>经过检测发现应该是POST的表单中ids的问题。<br>用袁仁义的账号时<code>ids=142846</code>，<br>而我的是<code>ids=159778</code>，<br>大概每个年级都不一样。<br>我现在掌握的账号有限，<br>学校后端也不开源，<br>这种开发真是相当心累了。<br>关于这个键的获取方式，应该可以GET</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;eams.uestc.edu.cn&#x2F;eams&#x2F;courseTableForStd.action?_&#x3D;</span><br></pre></td></tr></table></figure>
<p>这个URL来获取，<br>老样子，<code>_</code>的值是unix时间戳（毫秒）。<br>请求之后可以用正则的方式来从html代码中获取，<br>那一行一般类似于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bg.form.addInput(form,&quot;ids&quot;,&quot;159778&quot;);</span><br></pre></td></tr></table></figure>
<p>那么正则的方式就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bg\.form\.addInput\(form\,\&quot;ids\&quot;\,\&quot;(.*?)\&quot;\)\;</span><br></pre></td></tr></table></figure>
<p>注意一般有两个，取第一个，<br>第二个是班级课表。<br>一般是6位，如果不是则抛异常。</p>
<h2 id="2018-08-23"><a href="#2018-08-23" class="headerlink" title="2018-08-23"></a>2018-08-23</h2><p>真是想怼死张义飞。<br>课程表用第一周的。</p>
<h2 id="2018-08-22"><a href="#2018-08-22" class="headerlink" title="2018-08-22"></a>2018-08-22</h2><p>又偷懒了几天。<br>准备开始写课程表了。<br>对于semesterId为空的情况，<br>需要手动获取当前的smesterId。<br>不出意外的话，<br>可以请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;eams.uestc.edu.cn&#x2F;eams&#x2F;courseTableForStd.action</span><br></pre></td></tr></table></figure>
<p>这个链接，GET方式，带一个参数<code>_</code>，<br>参数值为当前时间，unix时间戳，毫秒。<br>然后会有Set-Cookie，<br>其中包含了<code>semester.id</code>，<br>它的值应该就是我们需要的。<br>我在写这些文字的时候是203。</p>
<h2 id="2018-08-19"><a href="#2018-08-19" class="headerlink" title="2018-08-19"></a>2018-08-19</h2><p>成绩信息里面，如果有重修的话，<br>会有span标签。  用正则替换搞定了。</p>
<p>又双叒叕出bug了。<br>如果有重修之类的数据，<br>在成绩详细信息就会有9个项目，<br>多了一个补考成绩，<br>放在第8位。<br>目前处理是，<br>去掉这个补考成绩，<br>主要保留的是最终成绩，<br>总评可有可无。<br>当然对我来说，<br>要处理的就是把补考给去掉就行。<br>如果该科没有补考，那么那一项是空的。<br>通过正则把td标签部分解析成数组之后，<br>判断数组的长度，如果是9就直接扔掉第8位。</p>
<p>嘛，最终还是决定把补考加上。<br>原因当然是比较方便改。</p>
<h2 id="2018-08-17"><a href="#2018-08-17" class="headerlink" title="2018-08-17"></a>2018-08-17</h2><p>修复check_token.php。<br>居然会有idas没过期，eams过期这种奇葩的情况。<br>check_token.php是之前写的，<br>当时还没有处理eams的情况。现在把eams的确认也加到check_token里面了。</p>
<p>学长果然是有做产品经理的潜力。<br>成绩信息部分改为获取全部，<br>几乎得重写，靠。<br>请求的URL为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;eams.uestc.edu.cn&#x2F;eams&#x2F;teach&#x2F;grade&#x2F;course&#x2F;person!historyCourseGrade.action?projectType&#x3D;MAJOR</span><br></pre></td></tr></table></figure>
<p>请求方式为POST，但是只提交一个<br><code>projectType=MAJOR</code>  反正我是看不懂这是什么操作。</p>
<p>最终还是在后端解析，用了几次正则，<br>把原来的那个全部注释了。<br>虽然有git，但是恢复起来并不是十分方便，<br>而且按PM的尿性，大家懂的。</p>
<h2 id="2018-08-16"><a href="#2018-08-16" class="headerlink" title="2018-08-16"></a>2018-08-16</h2><p>学校开放了eams，也就是教务处，<br>现在理论上是可以登录的，<br>然而小程序似乎还是不工作，<br>不太清楚为什么，等老哥上线吧。</p>
<p>同时修复了exam，grade等等的问题，login的时候塞入了明文token，已经修正。</p>
<p>小程序的问题似乎是没有POST数据，<br>不确定是不是格式的问题，<br>www-urlencoded或者form-data。<br>总之PHP是没收到数据，从日志来看。</p>
<h2 id="2018-08-14"><a href="#2018-08-14" class="headerlink" title="2018-08-14"></a>2018-08-14</h2><p>好多天没有写了。主要是懒，对，我被学长感染了。<br>学长把接口文档修改成他希望的样子，<br>很多地方有比较大的改动，<br>真是有做产品经理的潜力啊。<br>域名备案终于过了，感谢祖国。</p>
<h2 id="2018-08-06"><a href="#2018-08-06" class="headerlink" title="2018-08-06"></a>2018-08-06</h2><p>课程表内容在js中，<br>首先还是得提取字符串。<br>关于响应的格式，<br>老哥让我自己去看他写的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Yidadaa&#x2F;UESTC_Helper&#x2F;blob&#x2F;master&#x2F;src&#x2F;components&#x2F;course&#x2F;parser.js#L95</span><br></pre></td></tr></table></figure>
<p>实在是太秀了。</p>
<p>总的来说，最后决定直接用老哥的代码。<br>在服务器搭建node环境，<br>然后php调用。</p>
<p>目前要做的就是爬取课程表html数据了。<br>URL如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;eams.uestc.edu.cn&#x2F;eams&#x2F;courseTableForStd!courseTable.action</span><br></pre></td></tr></table></figure>
<p>请求方式为POST，参数包括</p>
<ul>
<li><code>ignoreHead</code> = 不知道，默认是1</li>
<li><code>setting.kind</code> = 学生课表:std/班级课表:class</li>
<li><code>startWeek</code> = 第几周</li>
<li><code>project.id</code> = 不知道，默认是1</li>
<li><code>semester.id</code> = 学期学年，老眼熟了</li>
<li><code>ids</code> = 貌似是学生课表(142846)/班级课表（5522）</li>
</ul>
<h2 id="2018-08-04"><a href="#2018-08-04" class="headerlink" title="2018-08-04"></a>2018-08-04</h2><p>前几天有点颓，就没做。</p>
<p>课程表似乎是用了js进行加载，<br>这就有些麻烦了。</p>
<p>考试信息似乎可以直接请求到，链接是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;eams.uestc.edu.cn&#x2F;eams&#x2F;stdExamTable!examTable.action?semester.id&#x3D;xxx&amp;examType.id&#x3D;1&amp;_&#x3D;xxx</span><br></pre></td></tr></table></figure>
<p>和成绩信息类似，不过多了一个<code>examType.id</code>，<br>应该是用来指定考试类型的。如下：</p>
<ul>
<li>1 = 期末考试</li>
<li>2 = 期中考试</li>
<li>3 = 补考</li>
<li>4 = 缓考</li>
</ul>
<p>另外两个参数就没什么了，和之前一样。</p>
<ul>
<li><code>semester.id</code> = 学年学期</li>
<li><code>_</code> = 时间（unix时间戳，毫秒）</li>
</ul>
<p>其中<code>semester.id</code>的默认值可以通过请求下面这个链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;eams.uestc.edu.cn&#x2F;eams&#x2F;stdExamTable.action</span><br></pre></td></tr></table></figure>
<p>响应值中的Set-Cookie中应该会有。</p>
<p>请求返回的html中包含一个table，<br>里面的内容就是课程信息了。<br>不过与成绩信息不同的是，其中可能会有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[考试情况尚未发布]</span><br></pre></td></tr></table></figure>
<p>这种值。<br>单独占用掉5个td标签，<br>属性中包含</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">colspan&#x3D;&quot;5&quot;</span><br></pre></td></tr></table></figure>
<p>用正则应该是可以处理的，并不是太难。<br>我在想怎么响应到客户端，<br>学长还没给我回复，<br>不知道最近又在约哪个妹子。</p>
<h2 id="2018-08-01"><a href="#2018-08-01" class="headerlink" title="2018-08-01"></a>2018-08-01</h2><p>计算token那一段感觉需要再处理下，只计算一轮hash就可以了。</p>
<p>另外就是目前token并没有防爆破，也没设置过期时间。</p>
<p>关于读取成绩信息，请求的URL为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;eams.uestc.edu.cn&#x2F;eams&#x2F;teach&#x2F;grade&#x2F;course&#x2F;person!search.action?semesterId&#x3D;xxx&amp;projectType&#x3D;&amp;_&#x3D;xxx</span><br></pre></td></tr></table></figure>
<p>显然，有三个参数</p>
<ul>
<li><code>semesterId</code>=学期（比如2017-2018第二学期=183）</li>
<li><code>projectType</code>=留空</li>
<li><code>_</code>=当前时间（unix时间戳，毫秒）<br>同时，提交的cookie也多了一个<code>semester.id</code>，<br>从数值上看应该是与<code>semesterId</code>一致的。<br>当然这个值是通过Set-Cookie获取的，<br>所以我只能从经验来判断规律了。</li>
</ul>
<hr>
<p>学长说他会把<code>semesterId</code>通过post提交上来，那我就不关心那玩意了。</p>
<p>还有一种情况就是，读取默认学期。<br>比如正常浏览的时候会发现，虽然有2018-2019学年第1学期，<br>但是系统默认并不会跳转到那个位置，<br>而是给出了2017-2018学年第2学期。<br>从加载的情况来看，应该是这个URL的作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;eams.uestc.edu.cn&#x2F;eams&#x2F;teach&#x2F;grade&#x2F;course&#x2F;person.action</span><br></pre></td></tr></table></figure>
<p>在不提交<code>semester.id</code>这个cookie的情况下，<br>该URL的响应包含Set-Cookie。<br>当然就是<code>semester.id</code>。它的值应该就是那个默认的学年学期。</p>
<p>成绩查询模块开发完成。<br>眼睛有点累，老王又不陪我打球，唉。<br>大概后期会放慢一些速度，<br>目前主要还剩课程表和考试信息，<br>搞定那两个就差不多了。<br>最后分析一下安全，<br>项目大概就可以进入稳定期。</p>
<h2 id="2018-07-31"><a href="#2018-07-31" class="headerlink" title="2018-07-31"></a>2018-07-31</h2><p>域名还没备案，无法接入微信。</p>
<h2 id="2018-07-30"><a href="#2018-07-30" class="headerlink" title="2018-07-30"></a>2018-07-30</h2><p>目前还是决定用这个URL来检测登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;eams.uestc.edu.cn&#x2F;eams&#x2F;home!submenus.action?menu.id&#x3D;</span><br></pre></td></tr></table></figure>
<p>发生302表示cookie失效，<br>如果是200则表示成功。<br>当然在此之前还是先处理下如何登录的问题。<br>PHP的CURL虽然支持302自动跳转，<br>但是导致的问题是header部分会全部串到一个字符串，<br>而显然我目前写的url库并不支持这样的处理，<br>所以我决定在目前不更新url库的情况下，<br>手动处理302。<br>这样的好处当然是能够处理同名但是不同域的cookie，<br>比如route和JSESSIONID。<br>对，就是这么恶心。<br>我大概会在某些时候写一个类似requests那样的库，<br>并且支持session对象，<br>用cookieJar的方式保存cookie等等。<br>但那是后话了，目前这个虽然不怎么好用，<br>但我个人觉得还是可以的。<br>最近学了一点正则，<br>修改了<code>url.php</code>中处理header字符串的方式。  </p>
<p>又出问题了，关于确认token有效的php。<br>学校似乎加了防御，总之就是我用了这个URL做验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;idas.uestc.edu.cn&#x2F;authserver&#x2F;index.do</span><br></pre></td></tr></table></figure>
<p>判断方式是302/200，<br>200=有效，302=无效。<br>然而现在发生的情况是会302跳转到某位置，然后再跳回来。<br>好像就是为了验证爬虫有没有302跳转能力？我擦，搞笑呢？<br>但是没办法，毕竟这不是我写的，我也改不了。<br>好歹改起来不算麻烦，把get模式设置为自动跳转，  </p>
<p>最后判断一下网页标题就OK。</p>
<p>回到eams。<br>网站有个三级域的cookie是<code>iPlanetDirectoryPro</code>。<br>我个人是感觉这玩意没有什么卵用，<br>登录idas之后，如果浏览器没有提交这么个cookie的话，<br>服务器会继续Set-Cookie，<br>但是这个cookie似乎并不参与验证，<br>只是丢失的话会通过302再Set回来。<br>最坑的是，服务器似乎也并不保存这么个玩意，<br>因为每次Set-Cookie的值都不一样……  </p>
<p>当然话是这么说，该加上去的还是加上去吧。</p>
<p>重新理一下eams的登录获取cookie的过程。<br>首先eams有三个cookie，其中一个是三级域名</p>
<ul>
<li><code>iPlanetDirectoryPro</code>（这个是三级域名的）</li>
<li><code>JSESSIONID</code></li>
<li><code>sto-id-20480</code></li>
</ul>
<p>具体过程就是，  </p>
<ul>
<li>请求<code>http://eams.uestc.edu.cn/eams/home!submenus.action</code></li>
<li>获得cookie:<code>sto-id-20480</code></li>
<li>跳转<code>http://idas.uestc.edu.cn/authserver/login?service=http%3A%2F%2Feams.uestc.edu.cn%2Feams%2Fhome%21submenus.action</code></li>
<li>提交idas的cookie，登录idas</li>
<li>获得cookie:<code>JSESSIONID_ids1</code><br>(注意这里会设置一个新的cookie，建议入库)</li>
<li>跳转<code>http://eams.uestc.edu.cn/eams/home!submenus.action?ticket=xxxxx</code><br>(需要注意的是这里ticket应该是用于验证，跳转速度一定要快，不然会500错误，<br>至于多快我就不知道了，反正尽量快吧)</li>
<li>跳转<code>http://eams.uestc.edu.cn/eams/home!submenus.action;jsessionid=xxxxx</code><br>(同上，这里的jsessionid大概也是用于验证)</li>
<li>状态码200，获得cookie:<code>JSESSIONID</code></li>
</ul>
<p>不过理论上来说，这里还没完，<br>最后一步跳转的页面显示是重复登录的情况，然后要点击继续。<br>然而那个点击此处，不出以外的话，其实是和请求的URL一样的。<br>这里不想揣测学校后台是个什么逻辑，<br>总之按照步骤最终获取<code>JSESSINID</code>就可以进入登录状态了。<br>还有一件事就是，<br>如果在请求第二个URL的时候没有附上<code>iPlanetDirectoryPro</code>，<br>那么这个页面会重新Set-Cookie，而且值一般是不同的。<br>当然有时候即使附上了，依然会有Set-Cookie。<br>反正我是看不到教务系统的操作了。<br>同时在第二个URL时，<br>一般会修改idas域的cookie<code>JSESSIONID_ids1</code>的值。<br>如果只是获取<code>JSESSIONID</code>，<br>那么在倒数第二个URL中就已经给出了。<br>但是为了方便使用，<br>建议最后再请求一次来“激活”（？）。</p>
<h2 id="2018-07-29"><a href="#2018-07-29" class="headerlink" title="2018-07-29"></a>2018-07-29</h2><p>感觉学校的网站，cookie用得十分玄学。<br>学校使用一个页面来完成登录（idas），<br>该页面只能生成该页面的cookie，以及一个主域名cookie。<br>对于新登录的情况，其他页面没有cookie，<br>这时候会一个302到idas，<br>把验证方式加到URL中的参数（ticket），然后再302，get，<br>到一个ticket页面，<br>同样的URL带参数。这一过程中会设定几个cookie，<br>ticket最后再302到原来的页面。</p>
<h2 id="2018-07-27"><a href="#2018-07-27" class="headerlink" title="2018-07-27"></a>2018-07-27</h2><p>首先是登录时候提交的表单，<br>表单一般分为form-data和x-www-urlencoded。<br>学校登录的那个网站是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;idas.uestc.edu.cn&#x2F;authserver&#x2F;login</span><br></pre></td></tr></table></figure>
<p>表单格式是后者(x-www-urlencoded)，<br>但是我被chrome坑了，<br>因为chrome上写的是Form Data。<br>如果提交的表单是form-data，<br>会导致响应500错误。<br>如果登录成功，应该会响应302，<br>然后会有几个Set-Cookie，建议全部保留。<br>实际上主要起作用的cookie就是CASTGC，<br>即使只有这一个，依然是登录状态。<br>或者也可以使用route和JSESSIONID_ids1(有时候是ids2之类的)，<br>这样登录的话会导致一个302跳转，<br>然后再次获取CASTGC。<br>登录其他网站的时候用到的cookie是iPlanetDirectoryPro，<br>虽然我不太理解为什么单独做一个用来跨站，<br>而且这个cookie还不能用来直接登录idas，<br>总之很坑爹就是了。<br>所以我建议保留所有的cookie，<br>大多数爬虫没有自动302跳转功能（至少curl没有），<br>跨站的时候要从idas获取一个地址用于跳转（比如portal的话是ticket），<br>跳转的那个页面会响应Set-Cookie，最后再跳转回来。<br>这一系列操作，如果爬虫不支持自动跳转的话，简直就是灾难。<br>不同的域名提交不同的cookie也需要注意，<br>cookieJar还是很有必要的（然而curl就是没有，你气不气？好怀念Python）。</p>
<h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><p>大概说一下验证码。<br>是否需要验证码，可以通过一下链接来确定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;idas.uestc.edu.cn&#x2F;authserver&#x2F;needCaptcha.html</span><br></pre></td></tr></table></figure>
<p>需要两个参数（不含引号）</p>
<ul>
<li><code>username</code> = 学号</li>
<li><code>_</code> = 当前时间（unix时间戳，单位毫秒），对，就是一个下划线，你没看错</li>
</ul>
<p>返回的内容一般有两种（不含引号）</p>
<ul>
<li><code>true\n</code> = 需要验证码，可以让用户先手动登录一次再退出</li>
<li><code>false\n</code> = 不需要验证码，可以直接登录</li>
</ul>
<p>如果不想太麻烦用户的话，可以直接获取验证码输入就行。<br>链接是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;idas.uestc.edu.cn&#x2F;authserver&#x2F;captcha.html</span><br></pre></td></tr></table></figure>

<p>这个连接是写在js里面的，<br>有时候（就是点换一张的时候）需要加一个参数ts，<br>至于值是多少我就不确定了，自己去看js代码吧。</p>
]]></content>
      <tags>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title>那些CSS动画</title>
    <url>/2021/03/20/%E9%82%A3%E4%BA%9BCSS%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>众所周知，CSS可以实现很多矢量动画。</p>
<p>比如这个菜单按钮</p>
<p class="codepen" data-height="303" data-theme-id="dark" data-default-tab="css,result" data-user="mrthanlon" data-slug-hash="PobMbLv" style="height: 303px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Menu button">
  <span>See the Pen <a href="https://codepen.io/mrthanlon/pen/PobMbLv">
  Menu button</a> by hzy (<a href="https://codepen.io/mrthanlon">@mrthanlon</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>

<span id="more"></span>

<p>三角形的加载动画</p>
<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="css,result" data-user="mrthanlon" data-slug-hash="NWbQdyb" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Triangle animation">
  <span>See the Pen <a href="https://codepen.io/mrthanlon/pen/NWbQdyb">
  Triangle animation</a> by hzy (<a href="https://codepen.io/mrthanlon">@mrthanlon</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>

]]></content>
      <tags>
        <tag>动画</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>一个好用的字典树模板(C++)</title>
    <url>/2021/06/21/%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E5%AD%97%E5%85%B8%E6%A0%91%E6%A8%A1%E6%9D%BF-C/</url>
    <content><![CDATA[<p>因为大多数题目的字符串都是小写字母，所以就按照这个设计了，共26个英文字母，每个节点占用26个char。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">array</span>&lt;TrieNode *, 26&gt; node;</span><br><span class="line">    TrieNode() : node(&#123;<span class="literal">nullptr</span>&#125;) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        TrieNode *ptr = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: s) &#123;</span><br><span class="line">            c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (ptr-&gt;node[c] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ptr-&gt;node[c] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr-&gt;node[c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        TrieNode* ptr = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: s) &#123;</span><br><span class="line">            c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (ptr-&gt;node[c] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ptr = ptr-&gt;node[c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
        <category>字典树</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>ICPC</tag>
        <tag>数据结构</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我把api.js封装成了node module这件事</title>
    <url>/2021/06/21/%E5%85%B3%E4%BA%8E%E6%88%91%E6%8A%8Aapi-js%E5%B0%81%E8%A3%85%E6%88%90%E4%BA%86node-module%E8%BF%99%E4%BB%B6%E4%BA%8B/</url>
    <content><![CDATA[<p>是的，现在<a href="">api.js</a>成为模块啦！但是我改了下名字，现在他叫<a href="">restful-proxy</a>，因为我实际上是对RESTful风格的API进行封装，而且用了Proxy，本来是想叫做<code>restful.js</code>的，无奈这个名字已经有人用了（虽然万年没更新，而且也没有我的抽象）。</p>
]]></content>
      <categories>
        <category>Web</category>
        <category>JavaScript</category>
        <category>Proxy</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>用C语言写堆</title>
    <url>/2021/08/23/%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%86%99%E5%A0%86/</url>
    <content><![CDATA[<p>也就是优先队列，我们知道STL中提供了一个好用的优先队列<code>priority_queue&lt;T&gt;</code>，C语言中起码有不少库（比如<code>librock</code>）提供了这玩意，所以写这玩意纯属造无意义的轮子。但是我写这玩意主要是因为最近在面试，至少遇到了两次让手写一个堆（不过当时都没写出来，毕竟不会真的有人要手写STL提供的算法和数据结构吧？不会吧？不会吧？），闲着也是闲着，不如锻炼一下，堆还是很好写的。</p>
<p>我写的这个版本用<code>void*</code>模拟泛型，同时能自动扩容，但是缺点也很多，就我自己的感觉是时间复杂度的常数肯定很大，虽然是$O(\log_2 n)$​​​​​，但是有大量的判断，而且插入位置也没有优化，只写了个简单的测试例，总之不推荐在生产环境用（STL不香吗？）。</p>
<span id="more"></span>

<script src="https://gist.github.com/MrThanlon/6d30782faf81924d30f25f233b0af4d8.js"></script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始用C写一个后端框架</title>
    <url>/2021/09/21/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%94%A8C%E5%86%99%E4%B8%80%E4%B8%AA%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://github.com/MrThanlon/libhttp-ev">项目地址</a></p>
<p><a href="https://www.techempower.com/benchmarks/">后端框架跑分</a></p>
</blockquote>
<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>Go有Gin，Java有Tomcat/Spring，Python有Django，PHP本身就是为后端而生，Node.js有http模块，而C/C++……有nginx(?)! 但是众所周知，nginx插件并不好写，而且nginx还要配置文件，实际上也没多少人用nginx插件来写Web后端。</p>
<p>所以我决定来做这件事，我对这个框架的目标是</p>
<ul>
<li>高性能，既然是用C写，性能一定是优先地位，争取暴打nginx</li>
<li>易用，类似于FaaS的开发和使用体验，如果还能有一个开发用的cli就更好了</li>
<li>灵活，低耦合，可插拔，高度自定义</li>
<li>轻量，少依赖</li>
<li>跨平台，至少支持Linux和macOS</li>
</ul>
<span id="more"></span>

<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>为了实现高性能，我们应该使用IO多路复用方案，例如Linux的epoll，BSD的kqueue，Windows的IOCP，好在libev可以做这件事，它在不同系统下会使用不同的系统调用，而且性能很强。</p>
<p>在操作socket方面，如果是静态文件可以使用sendfile来减少内核拷贝，也可以减少处理过程中请求和释放堆内存。</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>另一方面就是HTTP协议解析，众所周知HTTP适合人类阅读但并不适合机器解析，我打算使用node.js的llhttp做这一部分，它基于llparser，生成C代码状态机，性能是足够的，如果以后有机会可以考虑手写或者用flex&amp;bison。</p>
<h3 id="开发体验"><a href="#开发体验" class="headerlink" title="开发体验"></a>开发体验</h3><p>对于FaaS来说，开发者只需要编写一个函数注册到某个路径上，接收请求参数，返回响应内容即可。我们的框架也应如此，所以在解析请求完成之后需要靠路径去分发请求，一个合理的想法是用字典树，他对于长度为$N$的字符串<strong>完整</strong>匹配的时间复杂度是$O(N)$，非常快，但是空间复杂度略高，不过既然是性能优先，那没事了。</p>
<h3 id="动态URL"><a href="#动态URL" class="headerlink" title="动态URL"></a>动态URL</h3><p>另外就是动态请求的问题，URL可能是动态的，我的想法是优先匹配最长的，例如开发者注册了<code>/user/profile</code>和<code>/user</code>，那么对于URL为<code>/user/profile/hzy</code>的请求则会调用前者提供的回调函数，而对于URL为<code>/user/pose</code>的则请求会调用后者，这样符合字典树的做法。不过有些时候开发者可能希望进行精确匹配，后期也许可以在设置中让开发者选择模糊匹配还是精确匹配。</p>
<h3 id="蓝图？"><a href="#蓝图？" class="headerlink" title="蓝图？"></a>蓝图？</h3><p>我希望能引入类似于Flask中的蓝图的概念，不过从实现的角度来说，这也是增加开销的，实际上Flask的蓝图不能递归，是否真的有必要呢？以后再说吧。</p>
<h3 id="单线程-VS-多线程-VS-多进程"><a href="#单线程-VS-多线程-VS-多进程" class="headerlink" title="单线程 VS 多线程 VS 多进程"></a>单线程 VS 多线程 VS 多进程</h3><p>向nginx学习，使用多进程架构，父进程只管理子进程并<code>wait()</code>，子进程<code>accept()</code>，这样连入的客户端会随机发往一个子进程上，每个子进程使用IO多路复用接收请求。nginx引入了一个互斥锁来减少“惊群”的开销，但是我暂时没看懂他是怎么做的，就先暂时这样吧。</p>
<p>当然进程数量也是可以设置的，如果开发者不希望使用多进程（例如开发调试的时候），那么就仅由主进程进行处理。既然使用了IO多路复用，那么单线程+CPU核心数的进程就足够了。</p>
<p>CPU进行多线程时切换上下文的开销并不小，考虑到默认情况下已经有CPU核心数量的进程了，默认就单线程吧。</p>
<p>不过可能有些用户希望以单进程多线程的方式运行，我个人对此并无意见。经过测试，可以直接多线程accept()，效果还是蛮好的，但是socket的分发不太随机，如果想要比较理想的负载均衡效果可能得自己实现一个阻塞队列来做，总之如果有时间的话可以考虑支持这种方式。</p>
<h3 id="基础设施函数"><a href="#基础设施函数" class="headerlink" title="基础设施函数"></a>基础设施函数</h3><p>主要是考虑静态目录，开发者应该能够直接将某个URL注册为静态资源，我们可以通过提供一些基础设施函数的方式来实现这一部分，用户只需要在handler中调用<code>http_send_dir()</code>即可将某个目录作为静态资源使用，同时还能提供部分文件类型的MIME。</p>
<p>另外就是数据库的操作，如果能封装成异步调用就更爽了。</p>
<h3 id="异步！异步！还是异步！"><a href="#异步！异步！还是异步！" class="headerlink" title="异步！异步！还是异步！"></a>异步！异步！还是异步！</h3><p>对于网站后端，一个很重要的操作就是对数据库的增删改查，实际上这属于IO操作，大多数的后端在这一部分都使用同步的方法，也就是等待数据库响应，那确实很方便，但是性能就不行了（多线程也可以解决，但是会引入另外的问题）。前面说过了，我们目前不打算支持多线程（即使将来支持多线程也不推荐使用），所以我们更应该使用异步的方式去进行数据库操作。那么为了实现异步，用户提供的回调函数应该是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">http_context_t</span> *context)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当完成请求时，调用<code>http_next(context)</code>进行后续的操作。</p>
<p>所以为什么不直接让函数返回要响应的内容呢？这就是关键点了，因为对于异步函数来说，我们并不知道它什么时候才实际完成，所以我们将这个返回的时机留给用户来决定，也方便用户执行异步调用。可惜C语言没有提供像js一样的async/await语法糖和闭包，不然写起来应该很爽。</p>
]]></content>
      <categories>
        <category>Web</category>
        <category>Backend</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Backend</tag>
      </tags>
  </entry>
  <entry>
    <title>交叉编译wxWidgets应用</title>
    <url>/2021/11/01/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91wxWidgets%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="引"><a href="#引" class="headerlink" title="引"></a>引</h1><p>众所周知wxWidgets是一个跨平台的GUI库，支持Linux(GTK/X11)，Windows和macOS(cocoa)，与Qt不同的是，他足够轻量，不需要魔改C++语言本身（qmake说的就是你），而且它调用平台原生API实现GUI，而Qt在Windows上实际上是绘制的界面，所以我打算用wxWidgets来做毕设。</p>
<p>众所周知Windows是现阶段的主流操作系统，而我用来写代码的电脑是mac，所以最终我可能仍然需要提供一个Windows版本的程序，但是我实在是不想在虚拟机上再折腾一套开发环境，所以就想着能不能直接在macOS或者Linux上编译出exe呢？答案是可以的，那就是mingw。</p>
<span id="more"></span>

<p>mingw(<strong>Min</strong>imalist <strong>G</strong>NU for <strong>W</strong>indows)是将GCC编译器和GNU Binutils移植到Win32平台下的产物，它是开源的软件，并且提供了macOS和Linux的版本，所以我们可以很容易的在macOS或者Linux上编译出exe。</p>
<p>接下来就是wxWidgets了，虽然官网提供了适用于mingw的预编译库，但是我自己测试发现不太能用，所以干脆直接从源码编译了。</p>
<h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><h2 id="安装mingw-w64"><a href="#安装mingw-w64" class="headerlink" title="安装mingw-w64"></a>安装mingw-w64</h2><p>首先需要安装mingw-w64，如果是macOS+Homebrew，那么可以直接brew</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install mingw-w64</span><br></pre></td></tr></table></figure>

<p>如果是Debian/Ubuntu，可以用apt安装，同时还要安装 <code>gcc-multilib</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install mingw-w64 gcc-multilib -y</span><br></pre></td></tr></table></figure>

<h2 id="下载wxWidgets源码并编译安装"><a href="#下载wxWidgets源码并编译安装" class="headerlink" title="下载wxWidgets源码并编译安装"></a>下载wxWidgets源码并编译安装</h2><p>建议从Github克隆仓库下来，因为我们只需要代码文件，不需要历史信息，所以可以加上 <code>--depth 1</code> 来减小仓库体积，以v3.1.5版本为例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --branch v3.1.5 --depth 1 https://github.com/wxWidgets/wxWidgets.git &amp;&amp; cd wxWidgets</span><br></pre></td></tr></table></figure>

<p>然后我们进入 <code>wxWidgets</code> 目录，创建一个目录 <code>build-win64</code> 用于保存编译wx时产生的中间文件，以及 <code>build-win64/install</code> 存放最终的预编译库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p build-win64/install &amp;&amp; cd build-win64</span><br></pre></td></tr></table></figure>

<p>我们进入了这个新创建的目录，现在需要运行wx的configure脚本，配置安装路径（<code>--prefix $PWD/install</code>）和交叉编译（<code>--host x86_64-w64-mingw32</code>，这是64位的，如果要编译32位的版本就使用<code>i686-w64-mingw32</code>），我们通常希望最后构建的exe能不需要其他依赖直接运行，所以动态库就没必要了（<code>--disable-shared</code>）。</p>
<p>最后的命令是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">../configure --prefix $PWD/install --host x86_64-w64-mingw32 --with-msw --enable-unicode --disable-shared</span><br></pre></td></tr></table></figure>

<p>等待configure完成，就可以执行make了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j4 # 4核处理器，如果你的电脑有更多核心的话建议指定更大的数字</span><br></pre></td></tr></table></figure>

<p>我自己的mac上是跑了挺久的，不过我在我们工作室的48核服务器上编译只用了3分钟左右。</p>
<p>总之编译完成后就可以安装了，安装命令是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>我们之前把安装路径指定到了 <code>build-win64/install</code> ，它不是系统路径所以不需要root权限，但是需要注意的是因为没有安装到系统路径，所以像cmake这样的构建工具很可能找不到依赖，所以我们就需要用 <code>wx-config</code> 命令来生成编译参数。</p>
<h2 id="编译wxWidgets应用"><a href="#编译wxWidgets应用" class="headerlink" title="编译wxWidgets应用"></a>编译wxWidgets应用</h2><p>在上一步的 <code>build-win64</code> 目录中有一个 <code>wx-config</code> 程序，他和 <code>pkg-config</code> 很像，可以用来生成编译参数，比如我们的应用是 <code>main.cpp</code> ，那么可以这样</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x86_64-w64-mingw32-g++ -o main.exe main.cpp -static `/path/to/wxWidgets/build-win64/wx-config --cxxflags --libs`</span><br></pre></td></tr></table></figure>

<p>如果之前编译的32位版本那就把编译器换成<code>i686-w64-mingw32-g++</code>。</p>
<p>如果没有问题的话会产生 <code>main.exe</code>，他可以直接放到Windows操作系统中运行。</p>
<h2 id="使用资源文件"><a href="#使用资源文件" class="headerlink" title="使用资源文件"></a>使用资源文件</h2><p>你可能会发现界面很丑，是Windows95的样式，如果你想要比较现代的界面，那么需要使用资源文件，wx提供了一个 <code>wx.rc</code>，用它就好了。</p>
<p>首先需要编译 <code>wx.rc</code>，用 <code>windres</code> 程序，这个程序包含在binutils里，之前可能没有安装，现在我们来安装他。</p>
<p>如果是macOS+Homebrew，可以直接brew</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install x86_64-elf-binutils # 64位，如果是32位的话是i686-elf-binutils</span><br></pre></td></tr></table></figure>

<p>如果是Debian/Ubuntu，可以用apt安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install binutils-mingw-w64 -y</span><br></pre></td></tr></table></figure>

<p>编译rc文件也很简单</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x86_64-w64-mingw32-windres /path/to/wxWidgets/include/msw/wx.rc `/path/to/wxWidgets/build-win64/wx-config --cxxflags` -O coff wx.res</span><br></pre></td></tr></table></figure>

<p>于是我们得到了 <code>wx.res</code> 文件，现在需要把他链接到程序里，这也很容易，首先我们在编译的时候先不要链接，而是编译到.o文件（注意命令加了个 <code>-c</code> ）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x86_64-w64-mingw32-g++ -o main.o -c main.cpp `/path/to/wxWidgets/build-win64/wx-config --cxxflags`</span><br></pre></td></tr></table></figure>

<p>然后在链接这一步加入 <code>wx.res</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x86_64-w64-mingw32-g++ -o main.exe main.o wx.res -static `/path/to/wxWidgets/build-win64/wx-config --libs`</span><br></pre></td></tr></table></figure>

<p>这样得到的 <code>main.exe</code> 就是带资源文件的，有一个wx默认的图标，并且界面风格也比较21世纪了。</p>
]]></content>
      <categories>
        <category>GUI</category>
        <category>wxWidgets</category>
      </categories>
      <tags>
        <tag>GUI</tag>
        <tag>C++</tag>
        <tag>交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title>使用shader加速三维点源阵仿真</title>
    <url>/2022/01/17/%E4%BD%BF%E7%94%A8shader%E5%8A%A0%E9%80%9F%E4%B8%89%E7%BB%B4%E7%82%B9%E6%BA%90%E9%98%B5%E4%BB%BF%E7%9C%9F/</url>
    <content><![CDATA[<p><a href="https://github.com/MrThanlon/array-field/">项目地址</a>/<a href="https://mrthanlon.github.io/array-field/">预览1</a>/<a href="https://codepen.io/mrthanlon/pen/KKXYVXN">预览2</a></p>
<h1 id="引"><a href="#引" class="headerlink" title="引"></a>引</h1><p>之前做了一个二维的点源阵仿真，还是挺简单的，D3.js直接画就完事了，但是这远远不够，工程上更多会考虑三维的情况。之前看了闫令琪老师的GAMES101和GAMES202，想着能不能趁着寒假在家用webgl做一个三维版本的。</p>
<span id="more"></span>

<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="二维情况"><a href="#二维情况" class="headerlink" title="二维情况"></a>二维情况</h2><p>虽然代码里写的应该挺清楚了，不过这里还是稍微整理一下，公式推导比较复杂，二维的也不是关键，所以这里直接给出结果，</p>
<p>点源阵方向图可以认为是一个半径变化的圆，我们需要知道所有点源的坐标（为了方便使用极坐标系）$(d_i,\theta_i)$和相位$\Phi_i$，对于任意方向$\phi$，方向图在这个方向的半径由以下公式给出<br>$$<br>r_\phi=|\exp(j\cdot\sum d_i\cos(\phi-\theta_i)+\Phi_i)| \<br>=\sqrt{\cos^2(\sum d_i\cos(\phi-\theta_i)+\Phi_i)+\sin^2(\sum d_i\cos(\phi-\theta_i)+\Phi_i)}<br>$$<br>其中$j$为虚数单位，</p>
<p>显然，当有$N$个点源和$M$个方向要计算的时候，复杂度为$O(MN)$，对于二维的情况$M$只需要几百即可达到肉眼看不出瑕疵的效果，对于CPU来说可以算是小菜一碟了。</p>
<h2 id="三维情况"><a href="#三维情况" class="headerlink" title="三维情况"></a>三维情况</h2><p>三维情况会比较复杂些，考虑使用球面坐标系，那么点源的坐标需要表示为三元组$(d_i,\phi_i,\theta_i)$，相位还是$\psi_i$，方向将变为二元组$(\phi,\theta)$，</p>
<p>现在我们计算$(\phi_i,\theta_i)$与$(\phi,\theta)$的夹角，用中学学过的向量知识我们知道，设他们的夹角是$\psi_i$那么有<br>$$<br>\cos\psi_i=\frac{\vec{u}\cdot\vec{v}}{|\vec{u}|\cdot|\vec{v}|}<br>$$<br>其中$\vec{u}$表示方向$(\phi_i,\theta_i)$的向量，$\vec{v}$表示$(\phi,\theta)$方向的向量，为了方便乘法计算我们变换到空间直角坐标系，并令$\vec{u}$和$\vec{v}$都为单位向量，得到<br>$$<br>\cos\psi_i=\sin\theta_i\cos\phi_i\sin\theta\cos\phi+\sin\theta_i\sin\phi_i\sin\theta\sin\phi+\cos\theta_i\cos\theta<br>$$<br>于是我们可以直接带入到之前二维的半径公式上，注意到二维中计算夹角很简单，只需要$\phi-\theta_i$，即现在我们将它用$\psi_i$进行替换，可得到三维情况下的半径公式<br>$$<br>r_{\phi,\theta}=|\exp(j\cdot \sum d_i\cos\psi_i+\Phi_i)| \<br>=\sqrt{\cos^2(\sum d_i\cos\psi_i+\Phi_i)+\sin^2(\sum d_i\cos\psi_i+\Phi_i)}<br>$$</p>
<h1 id="GPU编程与三维模型展示"><a href="#GPU编程与三维模型展示" class="headerlink" title="GPU编程与三维模型展示"></a>GPU编程与三维模型展示</h1><p>为了方便我就直接用three.js了，它能够很方便地利用WebGL展示三维模型，同时也支持自行编写着色器程序（ShaderMaterial）。</p>
<p>按我自己实验，要想达到比较好的效果，采样点会上万，这样的计算量对于CPU来说很难做到实时计算了，因此我们需要通过并行计算更强大的GPU来完成。</p>
<h2 id="TODO-使用顶点着色器（vertex-shader）"><a href="#TODO-使用顶点着色器（vertex-shader）" class="headerlink" title="TODO: 使用顶点着色器（vertex shader）"></a>TODO: 使用顶点着色器（vertex shader）</h2><p>在三维渲染中，顶点着色器主要完成MVP(Model, View, Perspect)矩阵变换，当然我们也可以夹一些私货进去，例如修改顶点的位置坐标。</p>
<p>为了进行计算和渲染，我们需要一个合适的三维模型，有些同学想既然二维是圆，那么三维自然就是球了，但是我们不能使用球面坐标，因为它并不均匀，为了使得模型更加均匀，我们使用的是正二十面体细分为球体，好在three.js中刚好提供了正二十面体的构造器（IcosahedronGeometry），而且支持细分，所以我们直接用它就好了。（关于为什么用正二十面体而不是正四/六/八/十二面体，因为正四/八面体细分之后还是不均匀，而正六/十二面体的面不是三角形，WebGL只能渲染三角形）。</p>
<h2 id="TODO-使用计算着色器（compute-shader）"><a href="#TODO-使用计算着色器（compute-shader）" class="headerlink" title="TODO: 使用计算着色器（compute shader）"></a>TODO: 使用计算着色器（compute shader）</h2><p>只是得到一个图案可不能叫仿真，我们有时候还要关心点源阵的实际参数，例如主波束宽度，定向性等。</p>
<p>可惜的是顶点着色器在计算完成后结果就直接传到片段着色器（fragment shader）中了，CPU是取不回来的，而如果既要使用GPU加速，又能够对计算结果进行分析的话，现代GPU编程给我们提供了一个更自由的工具，也就是计算着色器。关于计算着色器我不打算在本文中详细介绍，有兴趣的同学可以自行搜索相关内容。</p>
<p>但是比较可惜的是，目前只有WebGL2.0能支持计算着色器，而且苹果的浏览器Safari直到15版本才支持WebGL2.0，而且还刚好不支持计算着色器。</p>
<h2 id="TODO-使用WebGPU"><a href="#TODO-使用WebGPU" class="headerlink" title="TODO: 使用WebGPU"></a>TODO: 使用WebGPU</h2><p>前面提到了Safari15的WebGL2.0并不支持计算着色器，所以对于iOS设备我们得想其他办法，例如WebGPU，不过截止本文发表，WebGPU在Safari15上还是试验性功能，需要在设置中开启，Chrome只有金丝雀测试版支持WebGPU。</p>
]]></content>
      <categories>
        <category>Web</category>
        <category>WebGL</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>原子操作与无锁队列</title>
    <url>/2022/02/26/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>关于无锁数据结构有很多介绍了，如果想获得开箱即用的方案可以直接找liblfds，不过考虑到liblfds常年没维护，所以很多时候还得自己写，这里记录一下如何用原子操作实现无锁队列。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="简单队列"><a href="#简单队列" class="headerlink" title="简单队列"></a>简单队列</h3><p>真的是很简单了，就是一个链表，我们使用结构体定义该链表的节点和链表本身</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue_node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">queue_node</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">queue_node</span> <span class="title">dummy</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">queue_node</span>* <span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_queue</span><span class="params">(struct <span class="built_in">queue</span>* <span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;dummy.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail = &amp;<span class="built_in">queue</span>-&gt;dummy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>有两种操作</p>
<ul>
<li><p>入队，就是把节点添加到尾部</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(struct <span class="built_in">queue</span>* <span class="built_in">queue</span>, struct queue_node* node)</span> </span>&#123;</span><br><span class="line">  node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">queue</span>-&gt;tail-&gt;next = node;</span><br><span class="line">  <span class="built_in">queue</span>-&gt;tail = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>出队，就是将头部节点移出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct queue_node* <span class="title">dequeue</span><span class="params">(struct <span class="built_in">queue</span>* <span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (&amp;<span class="built_in">queue</span>-&gt;dummy == <span class="built_in">queue</span>-&gt;tail) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_node</span>* <span class="title">old_head</span> =</span> <span class="built_in">queue</span>-&gt;dummy.next;</span><br><span class="line">  <span class="built_in">queue</span>-&gt;dummy.next = old_head-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> old_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>当然也可以反过来，入队从头部插入，出队从尾部移出，本文不介绍这种方法。</p>
<h3 id="并行-并发环境"><a href="#并行-并发环境" class="headerlink" title="并行/并发环境"></a>并行/并发环境</h3><p>我们可以发现，入队和出队都至少需要两条指令，所以这样的代码在并行或者并发环境下就可能会出现一致性问题，所以我们通常会引入同步机制（例如互斥量）来保证一致性，但互斥量不是免费的午餐，加锁和释放都有一定开销，能不能借助CPU的原子指令来完成这些操作呢？答案是可以的。</p>
<h2 id="原子指令"><a href="#原子指令" class="headerlink" title="原子指令"></a>原子指令</h2><p>所谓原子，即不可分割的意思（当然我们知道实际上原子还能分为原子核和电子），在计算机中通常表示指令要么完成要么失败，不会发生只完成一半的情况。</p>
<h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>一个很常见的例子就是如何给变量自增，很多大聪明可能觉得这怎么会是问题呢？直接i++不就完事了？当然，对于单线程的情况下，确实很简单，但是如果有多个线程同时对同一个变量进行操作，那结果可能就不正确了。</p>
<p>例如现在x=0，有两个线程A和B同时执行x++，正确的结果应该是2，但是很有可能结果是1，原因是一般来说自增运算并不是原子的。这里要引入内存和寄存器的概念，在CPU中，访问寄存器是最快的，通常只需要一个时钟周期，但是访问内存通常需要几百个时钟周期（缓存未命中），而我们的变量通常是放在内存里的，所以对于自增操作，首先需要从内存读取到寄存器，然后对寄存器中的值+1，最后再写回内存，如果从汇编语言来看就很清楚了，比如函数中x++的汇编可能是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov	-4(%rbp), %eax</span><br><span class="line">add	$1, %eax</span><br><span class="line">mov	%eax, -4(%rbp)</span><br></pre></td></tr></table></figure>

<p>可以发现总共有三条汇编指令，假设A和B线程执行顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A B</span><br><span class="line">1   -&gt; A线程访存，A.eax&#x3D;0</span><br><span class="line">  1 -&gt; B线程访存，B.eax&#x3D;0</span><br><span class="line">2   -&gt; A线程执行自增1，A.eax&#x3D;1</span><br><span class="line">  2 -&gt; B线程执行自增1，B.eax&#x3D;1</span><br><span class="line">3   -&gt; A线程写存，由于A.eax&#x3D;1，所以内存中的值变成1</span><br><span class="line">  3 -&gt; B线程写存，由于B.eax&#x3D;1，所以内存中的值还是1</span><br></pre></td></tr></table></figure>

<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>聪明的小伙伴应该已经想到了，我们可以用互斥量（mutex，也可以叫互斥锁）保护x++这个语句，这样在某个线程完成自增前，另一个线程会被阻塞，使得自增操作“变成”原子操作。</p>
<p>同理对于任何需要防止被中断的操作，都可以使用互斥量来完成。</p>
<h3 id="CPU提供的原子操作"><a href="#CPU提供的原子操作" class="headerlink" title="CPU提供的原子操作"></a>CPU提供的原子操作</h3><p>互斥量并不是免费的午餐，加锁和释放都有一定的开销，实际上大多数CPU提供了一些指令可以帮助我们同时完成多项本来需要多条指令才能完成操作，我们将其称为原子指令，GCC编译器提供了一大票原子指令，你可以点击<a href="https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html">这里</a>查看，对于无锁队列，涉及的主要是两个</p>
<ul>
<li><p>交换（Exchange），gcc中是<code>__atomic_exchange_n</code>和<code>__atomic_exchange</code></p>
<ul>
<li><p><code>__atomic_exchange_n</code>接收一个指针ptr和值val，会对*ptr和val进行交换，相当于将</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type tmp = *ptr;</span><br><span class="line">*ptr = val;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br></pre></td></tr></table></figure>

<p>合并为一条指令。</p>
</li>
<li><p><code>__atomic_exchange</code>与上面那个相同，但是返回值通过指针传入。</p>
</li>
</ul>
</li>
<li><p>比较并交换（Compare And Swap，简称CAS），gcc中是<code>__atomic_compare_exchange_n</code>和<code>__atomic_compare_exchange</code></p>
<ul>
<li><p><code>__atomic_compare_exchange_n</code>接收两个指针ptr和expected和一个值desired，会比较*ptr与*expected是否相等，如果相等则将desired写入*ptr，否则将*ptr写入*expected，相当于将</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (*ptr == *expected) &#123;</span><br><span class="line">  *ptr = desired;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  *expected = *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并为一条指令。</p>
</li>
<li><p><code>__atomic_compare_exchange</code>与上面那个等同，但desired通过指针传入。</p>
</li>
</ul>
</li>
</ul>
<h2 id="无锁队列"><a href="#无锁队列" class="headerlink" title="无锁队列"></a>无锁队列</h2><p>终于进入正题了，现在我们尝试用原子指令实现不需要互斥量的入队和出队函数。</p>
<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>观察入队函数可以发现，只要执行修改的两条指令中间不被其他线程的入队函数打断就不会出现一致性问题，在看二、三条指令，其实就是将new_node与tail进行了一次交换，并将原tail的next设置为new_node，我们可以用原子指令中的交换来完成。改写如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(struct <span class="built_in">queue</span>* <span class="built_in">queue</span>, struct queue_node* node)</span> </span>&#123;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// let queue-&gt;tail = node，and let the old queue-&gt;tail-&gt;next point to node</span></span><br><span class="line">    __atomic_exchange_n(&amp;<span class="built_in">queue</span>-&gt;tail, node, __ATOMIC_RELAXED)-&gt;next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><h5 id="如果不用原子指令？"><a href="#如果不用原子指令？" class="headerlink" title="如果不用原子指令？"></a>如果不用原子指令？</h5><p>有大聪明可能会问，那如果直接先<code>queue-&gt;tail = node;</code>，再回去找父节点让它的<code>next</code>指向<code>node</code>不也可以吗？也就是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue_node</span>* <span class="title">old_tail</span> =</span> <span class="built_in">queue</span>-&gt;tail;</span><br><span class="line"><span class="built_in">queue</span>-&gt;tail = node;</span><br><span class="line">old_tail-&gt;next = node;</span><br></pre></td></tr></table></figure>

<p>这里会出现一个问题，那就是<code>old_tail</code>是不是真的是原来那个<code>old_tail</code>，在并行/并发的情况下，很可能执行完<code>old_tail = queue-&gt;tail;</code>后其他线程刚好执行完入队，那么就会导致<code>queue-&gt;tail</code>发生改变，于是<code>old_tail</code>就不是原来那个<code>old_tail</code>了。</p>
<h5 id="atomic-exchange-n-xxx-gt-next-node-并不是原子的，为什么没有影响？"><a href="#atomic-exchange-n-xxx-gt-next-node-并不是原子的，为什么没有影响？" class="headerlink" title="__atomic_exchange_n(xxx)-&gt;next = node; 并不是原子的，为什么没有影响？"></a><code>__atomic_exchange_n(xxx)-&gt;next = node;</code> 并不是原子的，为什么没有影响？</h5><p>大聪明们也许注意到了，确实，这并不是在原子操作中的，但也确实不会发生一致性问题。注意到原子交换返回的一定是交换出来的那个<code>queue-&gt;tail</code>，不会是其他节点，所以即使中间被其他线程打断，这个赋值也不会有问题。</p>
<h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p>如果不检查队列非空，那么与入队一样可以直接用交换实现出队，但显然我们不应该允许空队列出队，所以出队函数稍微复杂一些。</p>
<p>我们首先要获得头节点的指针，并将其与尾节点指针比较，如果两者不相等（非空）那么就将头节点与头节点的下一个节点进行交换并返回头节点，否则返回NULL。</p>
<p>然而遗憾的是，CAS和交换都并不能直接做这么一件事，我们只能缓存head，然后在判断完成非空时再比较head是不是原来那个head，如果是则交换出去，不是则继续尝试出队或返回NULL。改写如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">node* <span class="title">dequeue</span><span class="params">(struct <span class="built_in">list</span>* <span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_node</span>* <span class="title">head</span> =</span> <span class="built_in">queue</span>-&gt;head;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">volatile</span> struct list_node*)head == (<span class="keyword">volatile</span> struct list_node*)<span class="built_in">queue</span>-&gt;tail) &#123;</span><br><span class="line">      <span class="comment">// 空队列，返回NULL</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果head还是queue-&gt;head则queue-&gt;head = head-&gt;next，否则head = queue-&gt;head并重新判断</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (!__atomic_compare_exchange_n(&amp;<span class="built_in">queue</span>-&gt;head, &amp;head, head-&gt;next, __ATOMIC_RELAXED));</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="volatile？"><a href="#volatile？" class="headerlink" title="volatile？"></a>volatile？</h4><p>还记得刚才寄存器与内存的同步问题吗？我们的编译器很聪明，编译器当然知道寄存器比内存快，所以编译器并不会在每次赋值的时候都真的去写存，因为编译器发现后面可能还会用到这个变量，所以编译器会等到真的需要写存的时候才会去写存。</p>
<p>但是编译器可能不知道<code>tail</code>这个变量会同时被多个线程访问，有可能别的线程入队时修改了内存中的<code>tail</code>，但是寄存器里的<code>tail</code>还是原来那个，所以我们需要告诉编译器别自作聪明，每次判断<code>head==queue-&gt;tail</code>的时候都给我从内存里拿，于是我们就可以用<code>volatile</code>关键字来标记<code>tail</code>，这样编译器会取消这一步的常量优化了。</p>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>TODO: </p>
<h2 id="没有银弹"><a href="#没有银弹" class="headerlink" title="没有银弹"></a>没有银弹</h2><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>有聪明的小伙伴可能发现了，出队的那个循环不就相当于自旋锁吗？正确的喵，就是自旋锁。</p>
<p>那么这个自旋锁会长时间阻塞吗？答案是不会，原子操作还是很快的，只要没有其他线程在出队就能成功，注意到如果队列为空会直接返回NULL，所以这并不是阻塞队列哦。</p>
<h3 id="原子指令开销"><a href="#原子指令开销" class="headerlink" title="原子指令开销"></a>原子指令开销</h3><p>既然原子指令这么好用，为什么大多数能用到的逻辑不使用原子指令呢？</p>
<p>其实原子指令也不是免费的午餐，但比互斥量便宜点。从CPU实现来说，如果遇到原子指令，那么CPU通常会阻塞其他核心访存，本质上也是锁，不过是硬件锁，相对互斥量来说开销会小一些。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>对于生产者/消费者模型，生产者入队，消费者出队，我们更需要的可能是阻塞队列，也就是当消费速度大于生产速度时，队列为空，那么消费者应该阻塞直到生产者生产，而不是直接返回NULL。</p>
]]></content>
      <categories>
        <category>并行与并发</category>
      </categories>
      <tags>
        <tag>并行</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>要把前端和后端写在同一个文件里</title>
    <url>/2022/10/21/%E8%A6%81%E6%8A%8A%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF%E5%86%99%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E9%87%8C/</url>
    <content><![CDATA[<p>假如我们需要设计一个需要密码才能登录的页面，某些偷懒的大聪明可以很容易地写出这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">password</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (password === <span class="string">&#x27;fuck&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;wrong password&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;login-button&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> password = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;password&#x27;</span>).value;</span><br><span class="line">    alert(<span class="keyword">await</span> login(password));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>如果读者有一定的Web开发经验，一定能一眼看出这段代码很好地解释了什么叫掩耳盗铃。</p>
<p>当然，如果你还看不出，那么我们稍微提示一下</p>
<blockquote>
<p>前端代码在浏览器中运行，用户可以很容易地拿到前端代码。</p>
</blockquote>
<p>所以只需要稍微分析一下，就能直接获得正确的密码“fuck“，这种在前端进行验证的行为显然只有大聪明才能写出来。</p>
<h2 id="那么，如果我们把验证部分放到后端进行呢？"><a href="#那么，如果我们把验证部分放到后端进行呢？" class="headerlink" title="那么，如果我们把验证部分放到后端进行呢？"></a>那么，如果我们把验证部分放到后端进行呢？</h2><p>好，你成功领悟到了前后端分离的核心思想，于是我们吭哧吭哧地搭了一个后台服务器，再吭哧吭哧地写API文档，最后吭哧吭哧地联调上线，最后在某个通宵的夜里，当所有功能正常通过测试，我们终于可以坐下来歇一口气：#&amp;¥*@&amp;#&amp;¥*&amp;%<em>(@&amp;#</em>$$*#%@……</p>
<h2 id="那么，我为什么不能直接在前端写后端的代码呢？"><a href="#那么，我为什么不能直接在前端写后端的代码呢？" class="headerlink" title="那么，我为什么不能直接在前端写后端的代码呢？"></a>那么，我为什么不能直接在前端写后端的代码呢？</h2><p>于是你得到了<a href="https://remix.run/">Remix</a>。</p>
<p>……</p>
<p>哈哈，开个玩笑，Remix虽然部分实现了这么个操作，但我认为依然不够灵活，因此，我尝试了设计一个编译器/框架/库库（总之随便你怎么叫吧，我就叫编译器了），让开发者可以同时在一个文件里写前和后端代码，并在编译时分离出前端和后端代码，进行分别部署。</p>
<h2 id="那么，它怎么用呢？"><a href="#那么，它怎么用呢？" class="headerlink" title="那么，它怎么用呢？"></a>那么，它怎么用呢？</h2><p>啊，实际上我还没写完，你问的太快了。</p>
<p>当然，在我写完之前，我觉得有必要整理一下当前的需求，并设计相应的语法出来。</p>
<h3 id="1-在注释中添加-remux-lt-名字-gt-标记该代码运行在哪个端上"><a href="#1-在注释中添加-remux-lt-名字-gt-标记该代码运行在哪个端上" class="headerlink" title="1. 在注释中添加 @remux &lt;名字&gt; 标记该代码运行在哪个端上"></a>1. 在注释中添加 @remux &lt;名字&gt; 标记该代码运行在哪个端上</h3><p>也可以是别的什么关键字，总之目前先用<code>remux</code>吧。</p>
<p>我们以上面的代码为例，进行如下修改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @remux server</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">password</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (password === <span class="string">&#x27;fuck&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;wrong password&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @remux client</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;login-button&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> password = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;password&#x27;</span>).value;</span><br><span class="line">    alert(<span class="keyword">await</span> login(password));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>好，现在编译器就知道了，**<code>login</code>函数在服务器上运行，下面那条语句只会在客户端上运行，在服务端上会被删除**。</p>
<p>于是我们发现了新的问题，客户端的函数怎么可能直接调用服务器上的函数呢？！所以接下来，我们需要使用RPC（Remote Process Call，远程过程调用）对非本端的函数进行封装。</p>
<h3 id="2-非本端的函数会封装成RPC"><a href="#2-非本端的函数会封装成RPC" class="headerlink" title="2. 非本端的函数会封装成RPC"></a>2. 非本端的函数会封装成RPC</h3><p>好吧，就算函数没问题了，但是变量怎么办呢？例如下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @remux server</span></span><br><span class="line"><span class="keyword">let</span> aServerVar = <span class="number">114514</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @remux client</span></span><br><span class="line">aServerVar += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>我们看到，经过编译后，<code>aServerVar</code>这个变量的声明在客户端上会消失，这就导致接下来<code>aServerVar += 1;</code>中的变量未声明而执行出错，我们不希望这种情况发生，因此我们给编译器设下第3条规则</p>
<h3 id="3-非本端的变量声明会被封装为Proxy并实现RPC"><a href="#3-非本端的变量声明会被封装为Proxy并实现RPC" class="headerlink" title="3. 非本端的变量声明会被封装为Proxy并实现RPC"></a>3. 非本端的变量声明会被封装为Proxy并实现RPC</h3><p>RPC真是太棒了，可是编译器<strong>并不关心开发者使用什么RPC方案</strong>，所以我们决定把RPC的具体实现留给开发者，编译器本身只负责封装</p>
<h3 id="4-与标记名关联的函数会被作为RPC客户端调用"><a href="#4-与标记名关联的函数会被作为RPC客户端调用" class="headerlink" title="4. 与标记名关联的函数会被作为RPC客户端调用"></a>4. 与标记名关联的函数会被作为RPC客户端调用</h3><p>具体来说呢，在客户端上，上面的<code>login</code>函数会被封装成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> clientInvoke(</span><br><span class="line">        <span class="string">&#x27;function&#x27;</span>,    <span class="comment">// this is a function RPC</span></span><br><span class="line">        <span class="string">&#x27;server&#x27;</span>,      <span class="comment">// the remote is server</span></span><br><span class="line">        <span class="string">&#x27;login&#x27;</span>,       <span class="comment">// function name is login</span></span><br><span class="line">        args           <span class="comment">// the arguments</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于变量声明，则会封装成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aServerVar = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">    [<span class="string">&#x27;server&#x27;</span>, <span class="string">&#x27;aServerVar&#x27;</span>],</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function">() =&gt;</span> &#123;&#125;, &#123;</span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="title">apply</span>(<span class="params">target, func, args</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> clientInvoke(&#123;</span><br><span class="line">                <span class="string">&#x27;proxy&#x27;</span>,   <span class="comment">// this is a proxy RPC</span></span><br><span class="line">                <span class="string">&#x27;server&#x27;</span>,  <span class="comment">// the remote is server</span></span><br><span class="line">                func,      <span class="comment">// the proxy handler name</span></span><br><span class="line">                args       <span class="comment">// handler arguments</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>而对于被调用的端，存在编译器提供的函数用于接收调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是编译器提供的！不需要开发者自己写</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">serverHandler</span>(<span class="params">mode, func, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mode === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (func) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是很简单？所以开发者只需要实现一下<code>xxxInvoke</code>函数，并写好相应的RPC服务（甚至可以直接在这个文件里写好），把参数一股脑传给<code>yyyHandler</code>，然后返回到<code>xxxInvoke</code>就完成啦，RPC从未如此简单。</p>
<p>也许对于一些没写过RPC的小白，这可能有一定困难，因此我们会尝试提供一个专为该编译器设计的RPC实现，以方便需要快速上手的玩家们。</p>
<p>当然，这也就意味着在<code>server</code>端上，<code>clientInvoke</code>和<code>clientHandler</code>是完全没必要的，所以</p>
<h3 id="5-非本端的RPC函数会被删除"><a href="#5-非本端的RPC函数会被删除" class="headerlink" title="5. 非本端的RPC函数会被删除"></a>5. 非本端的RPC函数会被删除</h3><p>我们还希望所有端都能共用一些代码，例如某些类型的声明、公共的函数、公共的变量等，所以</p>
<h3 id="6-未标记的代码所有端上都会执行"><a href="#6-未标记的代码所有端上都会执行" class="headerlink" title="6. 未标记的代码所有端上都会执行"></a>6. 未标记的代码所有端上都会执行</h3><p>但是有些代码我们压根就不希望被其他端调用，例如私有的函数或是变量，尽管可以在RPC层面做限制（RPC必须有限制，不然会产生任意执行漏洞），但是我们还是可以让编译器做一些处理，在此，我想出了两种方案</p>
<ul>
<li><p>使用块语句，例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @remux server</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">aPrivateFunction</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> aPrivateVar = <span class="number">1919810</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式的好处是不会破坏JavaScript语法，坏处是可能无法实现某些功能，例如在公共函数中调用私有函数或变量（当然反过来没问题，在私有语句中调用公共函数或变量）</p>
</li>
<li><p>使用额外的标记，例如<code>// @remux server private</code>声明私有的变量和函数，这样在其他端上会被抹去，而不是封装成RPC，但是这种做法会对语法造成一定的破坏，这是我不太希望看到的，尽管编译器可以对不正确的变量或函数使用进行警告或报错，但依然会对开发者在编写程序上造成一定的困惑</p>
</li>
</ul>
<p>对于这个需求的实现方法我还在犹豫不决，因此，如果你有好的想法欢迎在下方留言处指点，或者直接与我交流，总之，在此保留第7条规则。</p>
]]></content>
      <categories>
        <category>Web</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>remux的一些调整</title>
    <url>/2022/11/12/remux%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B0%83%E6%95%B4/</url>
    <content><![CDATA[<p>在<a href="/2022/10/21/%E8%A6%81%E6%8A%8A%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF%E5%86%99%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E9%87%8C/">上一篇文章</a>中我描述了一个更强大的JavaScript全栈框架。好吧，我承认他在设计有很多失误，当然，为了避免以后再发生这样的事情我决定还是要先做足充分的调研和实践再开始进行设计，总之就放在那提醒自己了。在本文中，我会纠正之前的错误（主要是实现非常困难以及没有必要的部分），并重新规划设计remux框架。</p>
<span id="more"></span>

<h2 id="关于远程变量"><a href="#关于远程变量" class="headerlink" title="关于远程变量"></a>关于远程变量</h2><p>最主要的一点是，Proxy无法拦截对对象本身的操作，由于我没有详细地查看文档，也没有自己动手实践，一拍脑袋搞出来这么个玩意。</p>
<p>回过头重新想了一下发现其实”远程变量“并没有那么有用，具体来说，一个允许其他端任意修改的空间本就不太有用，还是应该封装成函数来处理，所以干脆就老老实实用RPC函数好了，别整什么远程变量。</p>
<h2 id="关于框架集成"><a href="#关于框架集成" class="headerlink" title="关于框架集成"></a>关于框架集成</h2><p>2022年，在后前端工程化时代，已经很少有单纯用一个脚本文件来糊页面了，需要考虑对React &amp; Vue 等库/框架的兼容性，一个页面一个js文件不太靠谱，但是一个模块一个js文件则非常优雅。</p>
<p>ESM已经逐渐成为规范，语法上只要兼容ESM就完事了，其实也不需要什么特别大的改动，只是需要额外处理下<code>import</code> / <code>export</code>。</p>
<p>我用洗澡的时间思考了一下，<code>import</code>按正常的对象声明处理即可，而<code>export</code>处理方法则与其<code>export</code>的类型做同样处理，这样可以完全当成一个正常模块使用，例如某个文件<code>import</code> RPC函数，那么也是导入的封装后的函数，完全没问题。</p>
<h2 id="关于遗留问题"><a href="#关于遗留问题" class="headerlink" title="关于遗留问题"></a>关于遗留问题</h2><p>私有对象还是很有必要的，我想到了一个非常优雅的解决方案：</p>
<p>众所周知，编译器可以找到那些不被使用的对象，所以对于不被某一端所使用的对象可以直接删除，达到私有的目的，当然这种做法在程序里包含了<code>eval</code>的情况下会失效，不过<code>eval</code>是一个比较危险的函数，大多数时候并不会使用，所以没问题，对于确实需要显式注明私有的对象，我们还是可以在语法上开洞。</p>
<h2 id="关于对象RPC"><a href="#关于对象RPC" class="headerlink" title="关于对象RPC"></a>关于对象RPC</h2><p>好像很少有人谈到过这个概念，也可能这是我自己造的概念。</p>
<p>具体来说，服务器端的RPC函数可以返回一个对象，然后经过序列化发送到客户端，客户端反序列化成对象，一切都很正常。然而并不是所有对象都能够这么做，比如某些有函数的对象，显然函数直接序列化是没有意义的，这就丢失了信息，客户端如果去调用对象的函数就会得到一个错误。举个例子，服务器的RPC函数是打开一个文件并返回文件的handler，接下来可以使用这个handler对文件进行读写，但是经过序列化 &amp; 反序列化后，客户端拿到这个对象是完全没有作用的，并不能直接对服务器的文件进行读写。</p>
<p>是真的不能吗？还记得Proxy吧，这就派上用场了，对于包含了函数的对象，我们用Proxy包裹成RPC，执行的时候发往服务端执行，然后再把结果反馈回来，这不就成了？</p>
<p>不过这是RPC的事情了，现阶段还在倒腾编译器，RPC以后再说吧。</p>
]]></content>
      <categories>
        <category>Web</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web</tag>
      </tags>
  </entry>
</search>
